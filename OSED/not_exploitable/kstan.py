#!/usr/bin/env python3
import os, sys, re, socket, binascii, time
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'


NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]       ; not_exploitable
KSTET [kstet_value]     ; exploitable
GTER [gter_value]       ; exploitable
HTER [hter_value]       ; exploitable
LTER [lter_value]       ; exploitable
KSTAN [lstan_value]     ; not_exploitable
EXIT

KSTAN isn't exploitable.  The basic block that performs the validation of the substring "KSTAN " goes off to the following basic block:

.text:004023E6 mov     dword ptr [esp+0Ch], 0 ; flags
.text:004023EE mov     dword ptr [esp+8], 0Fh ; len
.text:004023F6 mov     dword ptr [esp+4], offset aKstanUnderway ; "KSTAN UNDERWAY\n"
.text:004023FE mov     eax, [ebp+s]
.text:00402401 mov     [esp], eax      ; s
.text:00402404 call    _send@16        ; send(x,x,x,x)
.text:00402409 sub     esp, 10h
.text:0040240C mov     [ebp+var_1C], eax
.text:0040240F jmp     loc_4024A9

As seen above, there is no memory manipulation calls, such as _strncpy, _memcpy, etc.  Nothing to exploit.

Execution then goes off to:
.text:004024A9 loc_4024A9:
.text:004024A9 cmp     [ebp+var_1C], 0FFFFFFFFh
.text:004024AD jnz     short loc_40252A

Which basically just tests if the send was successful. If it was, loop back around to the _recv call and go through all the opcode handlers.  If not, execution goes off to print an error message and close the socket, return from the connection handler.
"""


def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

badchars = "\x00\x2e"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def sender_sockreuse(sock,buf):
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)



    oflow_sz = 0x1000
    opcode = "KSTAN "
    slack = "\x41" * oflow_sz
    buf = f"{opcode}{slack}"

    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

if __name__=="__main__":
    main()

